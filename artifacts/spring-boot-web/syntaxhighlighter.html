<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>Untitled</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
<link rel="stylesheet"
    href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
    integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
    crossorigin="anonymous">
<link rel="stylesheet"
    href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css"
    integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp"
    crossorigin="anonymous">

<style>
    .c2cb{
        position: absolute; left: 0; top: 0;
        cursor: pointer
    }
    .c2cb:focus {
        outline: none;
    }
    body {
        font-size: 18px;
    }

    p {
        font-size: 18px;
    }

    td.content {
        font-size:2.0625rem;
    }

    div.title {
        font-size:2.0625rem;
    }
</style>

<script src="js/jquery-3.2.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script>

    $(function() {
        var button = $("<div style='padding: 10px;'><button data-toggle='tooltip' placement='right' data-trigger='click' title='Copied!'  class='c2cb glyphicon glyphicon-copy'></button></div>");
        $(".listingblock > .content pre").prepend(button);

        $('[data-toggle="tooltip"]').tooltip();

        $('[data-toggle="tooltip"]').mouseout(function() {
            $(this).tooltip('hide');
            $(this).trigger('blur');
        });

        var clipboard = new Clipboard('.c2cb', {
            target: function(c2cb) {
                        return $(c2cb).parent().siblings("code")[0];
                    }
                });
            clipboard.on('success', function(e) {
                e.clearSelection();
            });
    });

</script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div id="spring-boot-web-artifact-syntaxhighlighter" class="listingblock">
<div class="title">syntaxhighlighter.js</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="comment">/*!
 * SyntaxHighlighter
 * https://github.com/syntaxhighlighter/syntaxhighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 4.0.1 (Tue, 05 Jul 2016 16:28:21 GMT)
 *
 * @copyright
 * Copyright (C) 2004-2016 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */</span>
<span class="comment">/******/</span> (<span class="keyword">function</span>(modules) { <span class="comment">// webpackBootstrap</span>
<span class="comment">/******/</span>         <span class="comment">// The module cache</span>
<span class="comment">/******/</span>         <span class="keyword">var</span> installedModules = {};
<span class="comment">/******/</span>
<span class="comment">/******/</span>         <span class="comment">// The require function</span>
<span class="comment">/******/</span>         <span class="keyword">function</span> <span class="function">__webpack_require__</span>(moduleId) {
<span class="comment">/******/</span>
<span class="comment">/******/</span>                 <span class="comment">// Check if module is in cache</span>
<span class="comment">/******/</span>                 <span class="keyword">if</span>(installedModules[moduleId])
<span class="comment">/******/</span>                         <span class="keyword">return</span> installedModules[moduleId].exports;
<span class="comment">/******/</span>
<span class="comment">/******/</span>                 <span class="comment">// Create a new module (and put it into the cache)</span>
<span class="comment">/******/</span>                 <span class="keyword">var</span> module = installedModules[moduleId] = {
<span class="comment">/******/</span>                         <span class="key">exports</span>: {},
<span class="comment">/******/</span>                         <span class="key">id</span>: moduleId,
<span class="comment">/******/</span>                         <span class="key">loaded</span>: <span class="predefined-constant">false</span>
<span class="comment">/******/</span>                 };
<span class="comment">/******/</span>
<span class="comment">/******/</span>                 <span class="comment">// Execute the module function</span>
<span class="comment">/******/</span>                 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
<span class="comment">/******/</span>
<span class="comment">/******/</span>                 <span class="comment">// Flag the module as loaded</span>
<span class="comment">/******/</span>                 module.loaded = <span class="predefined-constant">true</span>;
<span class="comment">/******/</span>
<span class="comment">/******/</span>                 <span class="comment">// Return the exports of the module</span>
<span class="comment">/******/</span>                 <span class="keyword">return</span> module.exports;
<span class="comment">/******/</span>         }
<span class="comment">/******/</span>
<span class="comment">/******/</span>
<span class="comment">/******/</span>         <span class="comment">// expose the modules object (__webpack_modules__)</span>
<span class="comment">/******/</span>         __webpack_require__.m = modules;
<span class="comment">/******/</span>
<span class="comment">/******/</span>         <span class="comment">// expose the module cache</span>
<span class="comment">/******/</span>         __webpack_require__.c = installedModules;
<span class="comment">/******/</span>
<span class="comment">/******/</span>         <span class="comment">// __webpack_public_path__</span>
<span class="comment">/******/</span>         __webpack_require__.p = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;
<span class="comment">/******/</span>
<span class="comment">/******/</span>         <span class="comment">// Load entry module and return exports</span>
<span class="comment">/******/</span>         <span class="keyword">return</span> __webpack_require__(<span class="integer">0</span>);
<span class="comment">/******/</span> })
<span class="comment">/************************************************************************/</span>
<span class="comment">/******/</span> ([
<span class="comment">/* 0 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        Object.defineProperty(exports, <span class="string"><span class="delimiter">&quot;</span><span class="content">__esModule</span><span class="delimiter">&quot;</span></span>, {
          <span class="key">value</span>: <span class="predefined-constant">true</span>
        });

        <span class="keyword">var</span> _core = __webpack_require__(<span class="integer">1</span>);

        Object.keys(_core).forEach(<span class="keyword">function</span> (key) {
          <span class="keyword">if</span> (key === <span class="string"><span class="delimiter">&quot;</span><span class="content">default</span><span class="delimiter">&quot;</span></span>) <span class="keyword">return</span>;
          Object.defineProperty(exports, key, {
            <span class="key">enumerable</span>: <span class="predefined-constant">true</span>,
            <span class="function">get</span>: <span class="keyword">function</span> <span class="function">get</span>() {
              <span class="keyword">return</span> _core[key];
            }
          });
        });

        <span class="keyword">var</span> _domready = __webpack_require__(<span class="integer">52</span>);

        <span class="keyword">var</span> _domready2 = _interopRequireDefault(_domready);

        <span class="keyword">var</span> _core2 = _interopRequireDefault(_core);

        <span class="keyword">var</span> _dasherize = __webpack_require__(<span class="integer">53</span>);

        <span class="keyword">var</span> dasherize = _interopRequireWildcard(_dasherize);

        <span class="keyword">function</span> <span class="function">_interopRequireWildcard</span>(obj) { <span class="keyword">if</span> (obj &amp;&amp; obj.__esModule) { <span class="keyword">return</span> obj; } <span class="keyword">else</span> { <span class="keyword">var</span> newObj = {}; <span class="keyword">if</span> (obj != <span class="predefined-constant">null</span>) { <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) { <span class="keyword">if</span> (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.<span class="keyword">default</span> = obj; <span class="keyword">return</span> newObj; } }

        <span class="keyword">function</span> <span class="function">_interopRequireDefault</span>(obj) { <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : { <span class="keyword">default</span>: obj }; }

        <span class="comment">// configured through the `--compat` parameter.</span>
        <span class="keyword">if</span> (<span class="predefined-constant">false</span>) {
          require(<span class="string"><span class="delimiter">'</span><span class="content">./compatibility_layer_v3</span><span class="delimiter">'</span></span>);
        }

        (<span class="integer">0</span>, _domready2.<span class="keyword">default</span>)(<span class="keyword">function</span> () {
          <span class="keyword">return</span> _core2.<span class="keyword">default</span>.highlight(dasherize.object(window.syntaxhighlighterConfig || {}));
        });

<span class="comment">/***/</span> },
<span class="comment">/* 1 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        Object.defineProperty(exports, <span class="string"><span class="delimiter">&quot;</span><span class="content">__esModule</span><span class="delimiter">&quot;</span></span>, {
          <span class="key">value</span>: <span class="predefined-constant">true</span>
        });
        <span class="keyword">var</span> optsParser = __webpack_require__(<span class="integer">2</span>),
            match = __webpack_require__(<span class="integer">5</span>),
            Renderer = __webpack_require__(<span class="integer">9</span>).<span class="keyword">default</span>,
            utils = __webpack_require__(<span class="integer">10</span>),
            transformers = __webpack_require__(<span class="integer">11</span>),
            dom = __webpack_require__(<span class="integer">17</span>),
            config = __webpack_require__(<span class="integer">18</span>),
            defaults = __webpack_require__(<span class="integer">19</span>),
            HtmlScript = __webpack_require__(<span class="integer">20</span>);

        <span class="keyword">var</span> sh = {
          <span class="key">Match</span>: match.Match,
          <span class="key">Highlighter</span>: __webpack_require__(<span class="integer">22</span>),

          <span class="key">config</span>: __webpack_require__(<span class="integer">18</span>),
          <span class="key">regexLib</span>: __webpack_require__(<span class="integer">3</span>).commonRegExp,

          <span class="comment">/** Internal 'global' variables. */</span>
          <span class="key">vars</span>: {
            <span class="key">discoveredBrushes</span>: <span class="predefined-constant">null</span>,
            <span class="key">highlighters</span>: {}
          },

          <span class="comment">/** This object is populated by user included external brush files. */</span>
          <span class="key">brushes</span>: {},

          <span class="comment">/**
           * Finds all elements on the page which should be processes by SyntaxHighlighter.
           *
           * @param {Object} globalParams   Optional parameters which override element's
           *                  parameters. Only used if element is specified.
           *
           * @param {Object} element  Optional element to highlight. If none is
           *              provided, all elements in the current document
           *              are returned which qualify.
           *
           * @return {Array}  Returns list of &lt;code&gt;{ target: DOMElement, params: Object }&lt;/code&gt; objects.
           */</span>
          <span class="function">findElements</span>: <span class="keyword">function</span> <span class="function">findElements</span>(globalParams, element) {
            <span class="keyword">var</span> elements = element ? [element] : utils.toArray(document.getElementsByTagName(sh.config.tagName)),
                conf = sh.config,
                result = [];

            <span class="comment">// support for &lt;SCRIPT TYPE=&quot;syntaxhighlighter&quot; /&gt; feature</span>
            elements = elements.concat(dom.getSyntaxHighlighterScriptTags());

            <span class="keyword">if</span> (elements.length === <span class="integer">0</span>) <span class="keyword">return</span> result;

            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>, l = elements.length; i &lt; l; i++) {
              <span class="keyword">var</span> item = {
                <span class="key">target</span>: elements[i],
                <span class="comment">// local params take precedence over globals</span>
                <span class="key">params</span>: optsParser.defaults(optsParser.parse(elements[i].className), globalParams)
              };

              <span class="keyword">if</span> (item.params[<span class="string"><span class="delimiter">'</span><span class="content">brush</span><span class="delimiter">'</span></span>] == <span class="predefined-constant">null</span>) <span class="keyword">continue</span>;

              result.push(item);
            }

            <span class="keyword">return</span> result;
          },

          <span class="comment">/**
           * Shorthand to highlight all elements on the page that are marked as
           * SyntaxHighlighter source code.
           *
           * @param {Object} globalParams   Optional parameters which override element's
           *                  parameters. Only used if element is specified.
           *
           * @param {Object} element  Optional element to highlight. If none is
           *              provided, all elements in the current document
           *              are highlighted.
           */</span>
          <span class="function">highlight</span>: <span class="keyword">function</span> <span class="function">highlight</span>(globalParams, element) {
            <span class="keyword">var</span> elements = sh.findElements(globalParams, element),
                propertyName = <span class="string"><span class="delimiter">'</span><span class="content">innerHTML</span><span class="delimiter">'</span></span>,
                brush = <span class="predefined-constant">null</span>,
                renderer,
                conf = sh.config;

            <span class="keyword">if</span> (elements.length === <span class="integer">0</span>) <span class="keyword">return</span>;

            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>, l = elements.length; i &lt; l; i++) {
              <span class="keyword">var</span> element = elements[i],
                  target = element.target,
                  params = element.params,
                  brushName = params.brush,
                  brush,
                  matches,
                  code;

              <span class="keyword">if</span> (brushName == <span class="predefined-constant">null</span>) <span class="keyword">continue</span>;

              brush = findBrush(brushName);

              <span class="keyword">if</span> (!brush) <span class="keyword">continue</span>;

              <span class="comment">// local params take precedence over defaults</span>
              params = optsParser.defaults(params || {}, defaults);
              params = optsParser.defaults(params, config);

              <span class="comment">// Instantiate a brush</span>
              <span class="keyword">if</span> (params[<span class="string"><span class="delimiter">'</span><span class="content">html-script</span><span class="delimiter">'</span></span>] == <span class="predefined-constant">true</span> || defaults[<span class="string"><span class="delimiter">'</span><span class="content">html-script</span><span class="delimiter">'</span></span>] == <span class="predefined-constant">true</span>) {
                brush = <span class="keyword">new</span> HtmlScript(findBrush(<span class="string"><span class="delimiter">'</span><span class="content">xml</span><span class="delimiter">'</span></span>), brush);
                brushName = <span class="string"><span class="delimiter">'</span><span class="content">htmlscript</span><span class="delimiter">'</span></span>;
              } <span class="keyword">else</span> {
                brush = <span class="keyword">new</span> brush();
              }

              code = target[propertyName];

              <span class="comment">// remove CDATA from &lt;SCRIPT/&gt; tags if it's present</span>
              <span class="keyword">if</span> (conf.useScriptTags) code = stripCData(code);

              <span class="comment">// Inject title if the attribute is present</span>
              <span class="keyword">if</span> ((target.title || <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>) != <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>) params.title = target.title;

              params[<span class="string"><span class="delimiter">'</span><span class="content">brush</span><span class="delimiter">'</span></span>] = brushName;

              code = transformers(code, params);
              matches = match.applyRegexList(code, brush.regexList, params);
              renderer = <span class="keyword">new</span> Renderer(code, matches, params);

              element = dom.create(<span class="string"><span class="delimiter">'</span><span class="content">div</span><span class="delimiter">'</span></span>);
              element.innerHTML = renderer.getHtml();

              <span class="comment">// id = utils.guid();</span>
              <span class="comment">// element.id = highlighters.id(id);</span>
              <span class="comment">// highlighters.set(id, element);</span>

              <span class="keyword">if</span> (params.quickCode) dom.attachEvent(dom.findElement(element, <span class="string"><span class="delimiter">'</span><span class="content">.code</span><span class="delimiter">'</span></span>), <span class="string"><span class="delimiter">'</span><span class="content">dblclick</span><span class="delimiter">'</span></span>, dom.quickCodeHandler);

              <span class="comment">// carry over ID</span>
              <span class="keyword">if</span> ((target.id || <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>) != <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>) element.id = target.id;

              target.parentNode.replaceChild(element, target);
            }
          }
        }; <span class="comment">// end of sh</span>

        <span class="comment">/**
         * Displays an alert.
         * @param {String} str String to display.
         */</span>
        <span class="keyword">function</span> <span class="function">alert</span>(str) {
          window.alert(<span class="string"><span class="delimiter">'</span><span class="content">SyntaxHighlighter</span><span class="content">\n</span><span class="content">\n</span><span class="delimiter">'</span></span> + str);
        };

        <span class="comment">/**
         * Finds a brush by its alias.
         *
         * @param {String} alias    Brush alias.
         * @param {Boolean} showAlert Suppresses the alert if false.
         * @return {Brush}        Returns bursh constructor if found, null otherwise.
         */</span>
        <span class="keyword">function</span> <span class="function">findBrush</span>(alias, showAlert) {
          <span class="keyword">var</span> brushes = sh.vars.discoveredBrushes,
              result = <span class="predefined-constant">null</span>;

          <span class="keyword">if</span> (brushes == <span class="predefined-constant">null</span>) {
            brushes = {};

            <span class="comment">// Find all brushes</span>
            <span class="keyword">for</span> (<span class="keyword">var</span> brushName <span class="keyword">in</span> sh.brushes) {
              <span class="keyword">var</span> brush = sh.brushes[brushName],
                  aliases = brush.aliases;

              <span class="keyword">if</span> (aliases == <span class="predefined-constant">null</span>) {
                <span class="keyword">continue</span>;
              }

              brush.className = brush.className || brush.aliases[<span class="integer">0</span>];
              brush.brushName = brush.className || brushName.toLowerCase();

              <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>, l = aliases.length; i &lt; l; i++) {
                brushes[aliases[i]] = brushName;
              }
            }

            sh.vars.discoveredBrushes = brushes;
          }

          result = sh.brushes[brushes[alias]];

          <span class="keyword">if</span> (result == <span class="predefined-constant">null</span> &amp;&amp; showAlert) alert(sh.config.strings.noBrush + alias);

          <span class="keyword">return</span> result;
        };

        <span class="comment">/**
         * Strips &lt;![CDATA[]]&gt; from &lt;SCRIPT /&gt; content because it should be used
         * there in most cases for XHTML compliance.
         * @param {String} original Input code.
         * @return {String} Returns code without leading &lt;![CDATA[]]&gt; tags.
         */</span>
        <span class="keyword">function</span> <span class="function">stripCData</span>(original) {
          <span class="keyword">var</span> left = <span class="string"><span class="delimiter">'</span><span class="content">&lt;![CDATA[</span><span class="delimiter">'</span></span>,
              right = <span class="string"><span class="delimiter">'</span><span class="content">]]&gt;</span><span class="delimiter">'</span></span>,

          <span class="comment">// for some reason IE inserts some leading blanks here</span>
          copy = utils.trim(original),
              changed = <span class="predefined-constant">false</span>,
              leftLength = left.length,
              rightLength = right.length;

          <span class="keyword">if</span> (copy.indexOf(left) == <span class="integer">0</span>) {
            copy = copy.substring(leftLength);
            changed = <span class="predefined-constant">true</span>;
          }

          <span class="keyword">var</span> copyLength = copy.length;

          <span class="keyword">if</span> (copy.indexOf(right) == copyLength - rightLength) {
            copy = copy.substring(<span class="integer">0</span>, copyLength - rightLength);
            changed = <span class="predefined-constant">true</span>;
          }

          <span class="keyword">return</span> changed ? copy : original;
        };

        <span class="keyword">var</span> brushCounter = <span class="integer">0</span>;

        exports.<span class="keyword">default</span> = sh;
        <span class="keyword">var</span> registerBrush = exports.<span class="function">registerBrush</span> = <span class="keyword">function</span> <span class="function">registerBrush</span>(brush) {
          <span class="keyword">return</span> sh.brushes[<span class="string"><span class="delimiter">'</span><span class="content">brush</span><span class="delimiter">'</span></span> + brushCounter++] = brush.<span class="keyword">default</span> || brush;
        };
        <span class="keyword">var</span> clearRegisteredBrushes = exports.<span class="function">clearRegisteredBrushes</span> = <span class="keyword">function</span> <span class="function">clearRegisteredBrushes</span>() {
          sh.brushes = {};
          brushCounter = <span class="integer">0</span>;
        };

        <span class="comment">/* an EJS hook for `gulp build --brushes` command
         * */</span>

        registerBrush(__webpack_require__(<span class="integer">23</span>));

        registerBrush(__webpack_require__(<span class="integer">24</span>));

        registerBrush(__webpack_require__(<span class="integer">22</span>));

        registerBrush(__webpack_require__(<span class="integer">25</span>));

        registerBrush(__webpack_require__(<span class="integer">26</span>));

        registerBrush(__webpack_require__(<span class="integer">27</span>));

        registerBrush(__webpack_require__(<span class="integer">28</span>));

        registerBrush(__webpack_require__(<span class="integer">29</span>));

        registerBrush(__webpack_require__(<span class="integer">30</span>));

        registerBrush(__webpack_require__(<span class="integer">31</span>));

        registerBrush(__webpack_require__(<span class="integer">32</span>));

        registerBrush(__webpack_require__(<span class="integer">33</span>));

        registerBrush(__webpack_require__(<span class="integer">34</span>));

        registerBrush(__webpack_require__(<span class="integer">35</span>));

        registerBrush(__webpack_require__(<span class="integer">36</span>));

        registerBrush(__webpack_require__(<span class="integer">37</span>));

        registerBrush(__webpack_require__(<span class="integer">38</span>));

        registerBrush(__webpack_require__(<span class="integer">39</span>));

        registerBrush(__webpack_require__(<span class="integer">40</span>));

        registerBrush(__webpack_require__(<span class="integer">41</span>));

        registerBrush(__webpack_require__(<span class="integer">42</span>));

        registerBrush(__webpack_require__(<span class="integer">43</span>));

        registerBrush(__webpack_require__(<span class="integer">44</span>));

        registerBrush(__webpack_require__(<span class="integer">45</span>));

        registerBrush(__webpack_require__(<span class="integer">46</span>));

        registerBrush(__webpack_require__(<span class="integer">47</span>));

        registerBrush(__webpack_require__(<span class="integer">48</span>));

        registerBrush(__webpack_require__(<span class="integer">49</span>));

        registerBrush(__webpack_require__(<span class="integer">50</span>));

        registerBrush(__webpack_require__(<span class="integer">51</span>));

        <span class="comment">/*

         */</span>

<span class="comment">/***/</span> },
<span class="comment">/* 2 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> XRegExp = __webpack_require__(<span class="integer">3</span>).XRegExp;

        <span class="keyword">var</span> BOOLEANS = { <span class="key"><span class="delimiter">'</span><span class="content">true</span><span class="delimiter">'</span></span>: <span class="predefined-constant">true</span>, <span class="key"><span class="delimiter">'</span><span class="content">false</span><span class="delimiter">'</span></span>: <span class="predefined-constant">false</span> };

        <span class="keyword">function</span> <span class="function">camelize</span>(key) {
          <span class="keyword">return</span> key.replace(<span class="regexp"><span class="delimiter">/</span><span class="content">-(</span><span class="char">\w</span><span class="content">+)</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="keyword">function</span> (match, word) {
            <span class="keyword">return</span> word.charAt(<span class="integer">0</span>).toUpperCase() + word.substr(<span class="integer">1</span>);
          });
        }

        <span class="keyword">function</span> <span class="function">process</span>(value) {
          <span class="keyword">var</span> result = BOOLEANS[value];
          <span class="keyword">return</span> result == <span class="predefined-constant">null</span> ? value : result;
        }

        module.exports = {
          <span class="function">defaults</span>: <span class="keyword">function</span> <span class="function">defaults</span>(target, source) {
            <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source || {}) {
              <span class="keyword">if</span> (!target.hasOwnProperty(key)) target[key] = target[camelize(key)] = source[key];
            }<span class="keyword">return</span> target;
          },

          <span class="function">parse</span>: <span class="keyword">function</span> <span class="function">parse</span>(str) {
            <span class="keyword">var</span> match,
                key,
                result = {},
                arrayRegex = XRegExp(<span class="string"><span class="delimiter">&quot;</span><span class="content">^</span><span class="char">\\</span><span class="content">[(?&lt;values&gt;(.*?))</span><span class="char">\\</span><span class="content">]$</span><span class="delimiter">&quot;</span></span>),
                pos = <span class="integer">0</span>,
                regex = XRegExp(<span class="string"><span class="delimiter">&quot;</span><span class="content">(?&lt;name&gt;[</span><span class="char">\\</span><span class="content">w-]+)</span><span class="delimiter">&quot;</span></span> + <span class="string"><span class="delimiter">&quot;</span><span class="char">\\</span><span class="content">s*:</span><span class="char">\\</span><span class="content">s*</span><span class="delimiter">&quot;</span></span> + <span class="string"><span class="delimiter">&quot;</span><span class="content">(?&lt;value&gt;</span><span class="delimiter">&quot;</span></span> + <span class="string"><span class="delimiter">&quot;</span><span class="content">[</span><span class="char">\\</span><span class="content">w%#-]+|</span><span class="delimiter">&quot;</span></span> + <span class="comment">// word</span>
            <span class="string"><span class="delimiter">&quot;</span><span class="char">\\</span><span class="content">[.*?</span><span class="char">\\</span><span class="content">]|</span><span class="delimiter">&quot;</span></span> + <span class="comment">// [] array</span>
            <span class="string"><span class="delimiter">'</span><span class="content">&quot;.*?&quot;|</span><span class="delimiter">'</span></span> + <span class="comment">// &quot;&quot; string</span>
            <span class="string"><span class="delimiter">&quot;</span><span class="content">'.*?'</span><span class="delimiter">&quot;</span></span> + <span class="comment">// '' string</span>
            <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="char">\\</span><span class="content">s*;?</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">g</span><span class="delimiter">&quot;</span></span>);

            <span class="keyword">while</span> ((match = XRegExp.exec(str, regex, pos)) != <span class="predefined-constant">null</span>) {
              <span class="keyword">var</span> value = match.value.replace(<span class="regexp"><span class="delimiter">/</span><span class="content">^['&quot;]|['&quot;]$</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>) <span class="comment">// strip quotes from end of strings</span>
              ;

              <span class="comment">// try to parse array value</span>
              <span class="keyword">if</span> (value != <span class="predefined-constant">null</span> &amp;&amp; arrayRegex.test(value)) {
                <span class="keyword">var</span> m = XRegExp.exec(value, arrayRegex);
                value = m.values.length &gt; <span class="integer">0</span> ? m.values.split(<span class="regexp"><span class="delimiter">/</span><span class="char">\s</span><span class="content">*,</span><span class="char">\s</span><span class="content">*</span><span class="delimiter">/</span></span>) : [];
              }

              value = process(value);
              result[match.name] = result[camelize(match.name)] = value;
              pos = match.index + match[<span class="integer">0</span>].length;
            }

            <span class="keyword">return</span> result;
          }
        };

<span class="comment">/***/</span> },
<span class="comment">/* 3 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        Object.defineProperty(exports, <span class="string"><span class="delimiter">&quot;</span><span class="content">__esModule</span><span class="delimiter">&quot;</span></span>, {
          <span class="key">value</span>: <span class="predefined-constant">true</span>
        });
        exports.commonRegExp = exports.XRegExp = <span class="predefined-constant">undefined</span>;

        <span class="keyword">var</span> _xregexp = __webpack_require__(<span class="integer">4</span>);

        <span class="keyword">var</span> _xregexp2 = _interopRequireDefault(_xregexp);

        <span class="keyword">function</span> <span class="function">_interopRequireDefault</span>(obj) { <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : { <span class="keyword">default</span>: obj }; }

        exports.XRegExp = _xregexp2.<span class="keyword">default</span>;
        <span class="keyword">var</span> commonRegExp = exports.commonRegExp = {
          <span class="key">multiLineCComments</span>: (<span class="integer">0</span>, _xregexp2.<span class="keyword">default</span>)(<span class="string"><span class="delimiter">'</span><span class="content">/</span><span class="char">\\</span><span class="content">*.*?</span><span class="char">\\</span><span class="content">*/</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gs</span><span class="delimiter">'</span></span>),
          <span class="key">singleLineCComments</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\/</span><span class="content">\/</span><span class="content">.*$</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
          <span class="key">singleLinePerlComments</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">#.*$</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
          <span class="key">doubleQuotedString</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">&quot;([^</span><span class="char">\\</span><span class="content">&quot;</span><span class="char">\n</span><span class="content">]|</span><span class="char">\\</span><span class="content">.)*&quot;</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
          <span class="key">singleQuotedString</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">'([^</span><span class="char">\\</span><span class="content">'</span><span class="char">\n</span><span class="content">]|</span><span class="char">\\</span><span class="content">.)*'</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
          <span class="key">multiLineDoubleQuotedString</span>: (<span class="integer">0</span>, _xregexp2.<span class="keyword">default</span>)(<span class="string"><span class="delimiter">'</span><span class="content">&quot;([^</span><span class="char">\\</span><span class="char">\\</span><span class="content">&quot;]|</span><span class="char">\\</span><span class="char">\\</span><span class="content">.)*&quot;</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gs</span><span class="delimiter">'</span></span>),
          <span class="key">multiLineSingleQuotedString</span>: (<span class="integer">0</span>, _xregexp2.<span class="keyword">default</span>)(<span class="string"><span class="delimiter">&quot;</span><span class="content">'([^</span><span class="char">\\</span><span class="char">\\</span><span class="content">']|</span><span class="char">\\</span><span class="char">\\</span><span class="content">.)*'</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gs</span><span class="delimiter">'</span></span>),
          <span class="key">xmlComments</span>: (<span class="integer">0</span>, _xregexp2.<span class="keyword">default</span>)(<span class="string"><span class="delimiter">'</span><span class="content">(&amp;lt;|&lt;)!--.*?--(&amp;gt;|&gt;)</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gs</span><span class="delimiter">'</span></span>),
          <span class="key">url</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\w</span><span class="content">+:</span><span class="content">\/</span><span class="content">\/</span><span class="content">[</span><span class="char">\w</span><span class="content">-.</span><span class="content">\/</span><span class="content">?%&amp;=:@;#]*</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
          <span class="key">phpScriptTags</span>: { <span class="key">left</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(&amp;lt;|&lt;)</span><span class="content">\?</span><span class="content">(?:=|php)?</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="key">right</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\?</span><span class="content">(&amp;gt;|&gt;)</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="key"><span class="delimiter">'</span><span class="content">eof</span><span class="delimiter">'</span></span>: <span class="predefined-constant">true</span> },
          <span class="key">aspScriptTags</span>: { <span class="key">left</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(&amp;lt;|&lt;)%=?</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="key">right</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">%(&amp;gt;|&gt;)</span><span class="delimiter">/</span><span class="modifier">g</span></span> },
          <span class="key">scriptScriptTags</span>: { <span class="key">left</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(&amp;lt;|&lt;)</span><span class="char">\s</span><span class="content">*script.*?(&amp;gt;|&gt;)</span><span class="delimiter">/</span><span class="modifier">gi</span></span>, <span class="key">right</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(&amp;lt;|&lt;)</span><span class="content">\/</span><span class="char">\s</span><span class="content">*script</span><span class="char">\s</span><span class="content">*(&amp;gt;|&gt;)</span><span class="delimiter">/</span><span class="modifier">gi</span></span> }
        };

<span class="comment">/***/</span> },
<span class="comment">/* 4 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports) {

        <span class="comment">/*!
         * XRegExp 3.1.0-dev
         * &lt;xregexp.com&gt;
         * Steven Levithan (c) 2007-2015 MIT License
         */</span>

        <span class="comment">/**
         * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and
         * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to
         * make your client-side grepping simpler and more powerful, while freeing you from related
         * cross-browser inconsistencies.
         */</span>

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="comment">/* ==============================
         * Private variables
         * ============================== */</span>

        <span class="comment">// Property name used for extended regex instance data</span>

        <span class="keyword">var</span> REGEX_DATA = <span class="string"><span class="delimiter">'</span><span class="content">xregexp</span><span class="delimiter">'</span></span>;
        <span class="comment">// Optional features that can be installed and uninstalled</span>
        <span class="keyword">var</span> features = {
            <span class="key">astral</span>: <span class="predefined-constant">false</span>,
            <span class="key">natives</span>: <span class="predefined-constant">false</span>
        };
        <span class="comment">// Native methods to use and restore ('native' is an ES3 reserved keyword)</span>
        <span class="keyword">var</span> nativ = {
            <span class="key">exec</span>: RegExp.prototype.exec,
            <span class="key">test</span>: RegExp.prototype.test,
            <span class="key">match</span>: String.prototype.match,
            <span class="key">replace</span>: String.prototype.replace,
            <span class="key">split</span>: String.prototype.split
        };
        <span class="comment">// Storage for fixed/extended native methods</span>
        <span class="keyword">var</span> fixed = {};
        <span class="comment">// Storage for regexes cached by `XRegExp.cache`</span>
        <span class="keyword">var</span> regexCache = {};
        <span class="comment">// Storage for pattern details cached by the `XRegExp` constructor</span>
        <span class="keyword">var</span> patternCache = {};
        <span class="comment">// Storage for regex syntax tokens added internally or by `XRegExp.addToken`</span>
        <span class="keyword">var</span> tokens = [];
        <span class="comment">// Token scopes</span>
        <span class="keyword">var</span> defaultScope = <span class="string"><span class="delimiter">'</span><span class="content">default</span><span class="delimiter">'</span></span>;
        <span class="keyword">var</span> classScope = <span class="string"><span class="delimiter">'</span><span class="content">class</span><span class="delimiter">'</span></span>;
        <span class="comment">// Regexes that match native regex syntax, including octals</span>
        <span class="keyword">var</span> nativeTokens = {
            <span class="comment">// Any native multicharacter token in default scope, or any single character</span>
            <span class="key"><span class="delimiter">'</span><span class="content">default</span><span class="delimiter">'</span></span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\\</span><span class="content">(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]</span><span class="char">\d</span><span class="content">*|x[</span><span class="char">\d</span><span class="content">A-Fa-f]{2}|u(?:[</span><span class="char">\d</span><span class="content">A-Fa-f]{4}|{[</span><span class="char">\d</span><span class="content">A-Fa-f]+})|c[A-Za-z]|[</span><span class="char">\s</span><span class="char">\S</span><span class="content">])|</span><span class="content">\(</span><span class="content">\?</span><span class="content">[:=!]|[?*+]</span><span class="content">\?</span><span class="content">|{</span><span class="char">\d</span><span class="content">+(?:,</span><span class="char">\d</span><span class="content">*)?}</span><span class="content">\?</span><span class="content">?|[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]</span><span class="delimiter">/</span></span>,
            <span class="comment">// Any native multicharacter token in character class scope, or any single character</span>
            <span class="key"><span class="delimiter">'</span><span class="content">class</span><span class="delimiter">'</span></span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\\</span><span class="content">(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[</span><span class="char">\d</span><span class="content">A-Fa-f]{2}|u(?:[</span><span class="char">\d</span><span class="content">A-Fa-f]{4}|{[</span><span class="char">\d</span><span class="content">A-Fa-f]+})|c[A-Za-z]|[</span><span class="char">\s</span><span class="char">\S</span><span class="content">])|[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]</span><span class="delimiter">/</span></span>
        };
        <span class="comment">// Any backreference or dollar-prefixed character in replacement strings</span>
        <span class="keyword">var</span> replacementToken = <span class="regexp"><span class="delimiter">/</span><span class="content">\$</span><span class="content">(?:{([</span><span class="char">\w</span><span class="content">$]+)}|(</span><span class="char">\d</span><span class="char">\d</span><span class="content">?|[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]))</span><span class="delimiter">/</span><span class="modifier">g</span></span>;
        <span class="comment">// Check for correct `exec` handling of nonparticipating capturing groups</span>
        <span class="keyword">var</span> correctExecNpcg = nativ.exec.call(<span class="regexp"><span class="delimiter">/</span><span class="content">()??</span><span class="delimiter">/</span></span>, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>)[<span class="integer">1</span>] === <span class="predefined-constant">undefined</span>;
        <span class="comment">// Check for ES6 `u` flag support</span>
        <span class="keyword">var</span> <span class="function">hasNativeU</span> = <span class="keyword">function</span> () {
            <span class="keyword">var</span> isSupported = <span class="predefined-constant">true</span>;
            <span class="keyword">try</span> {
                <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">u</span><span class="delimiter">'</span></span>);
            } <span class="keyword">catch</span> (exception) {
                isSupported = <span class="predefined-constant">false</span>;
            }
            <span class="keyword">return</span> isSupported;
        }();
        <span class="comment">// Check for ES6 `y` flag support</span>
        <span class="keyword">var</span> <span class="function">hasNativeY</span> = <span class="keyword">function</span> () {
            <span class="keyword">var</span> isSupported = <span class="predefined-constant">true</span>;
            <span class="keyword">try</span> {
                <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">y</span><span class="delimiter">'</span></span>);
            } <span class="keyword">catch</span> (exception) {
                isSupported = <span class="predefined-constant">false</span>;
            }
            <span class="keyword">return</span> isSupported;
        }();
        <span class="comment">// Check for ES6 `flags` prop support</span>
        <span class="keyword">var</span> hasFlagsProp = <span class="regexp"><span class="delimiter">/</span><span class="content">a</span><span class="delimiter">/</span></span>.flags !== <span class="predefined-constant">undefined</span>;
        <span class="comment">// Tracker for known flags, including addon flags</span>
        <span class="keyword">var</span> registeredFlags = {
            <span class="key">g</span>: <span class="predefined-constant">true</span>,
            <span class="key">i</span>: <span class="predefined-constant">true</span>,
            <span class="key">m</span>: <span class="predefined-constant">true</span>,
            <span class="key">u</span>: hasNativeU,
            <span class="key">y</span>: hasNativeY
        };
        <span class="comment">// Shortcut to `Object.prototype.toString`</span>
        <span class="keyword">var</span> toString = {}.toString;

        <span class="comment">/* ==============================
         * Private functions
         * ============================== */</span>

        <span class="comment">/**
         * Attaches extended data and `XRegExp.prototype` properties to a regex object.
         *
         * @private
         * @param {RegExp} regex Regex to augment.
         * @param {Array} captureNames Array with capture names, or `null`.
         * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.
         * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.
         * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal
         *   operations, and never exposed to users. For internal-only regexes, we can improve perf by
         *   skipping some operations like attaching `XRegExp.prototype` properties.
         * @returns {RegExp} Augmented regex.
         */</span>
        <span class="keyword">function</span> <span class="function">augment</span>(regex, captureNames, xSource, xFlags, isInternalOnly) {
            <span class="keyword">var</span> p;

            regex[REGEX_DATA] = {
                <span class="key">captureNames</span>: captureNames
            };

            <span class="keyword">if</span> (isInternalOnly) {
                <span class="keyword">return</span> regex;
            }

            <span class="comment">// Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value</span>
            <span class="keyword">if</span> (regex.__proto__) {
                regex.__proto__ = XRegExp.prototype;
            } <span class="keyword">else</span> {
                <span class="keyword">for</span> (p <span class="keyword">in</span> XRegExp.prototype) {
                    <span class="comment">// An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since</span>
                    <span class="comment">// this is performance sensitive, and enumerable `Object.prototype` or</span>
                    <span class="comment">// `RegExp.prototype` extensions exist on `regex.prototype` anyway</span>
                    regex[p] = XRegExp.prototype[p];
                }
            }

            regex[REGEX_DATA].source = xSource;
            <span class="comment">// Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order</span>
            regex[REGEX_DATA].flags = xFlags ? xFlags.split(<span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>).sort().join(<span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>) : xFlags;

            <span class="keyword">return</span> regex;
        }

        <span class="comment">/**
         * Removes any duplicate characters from the provided string.
         *
         * @private
         * @param {String} str String to remove duplicate characters from.
         * @returns {String} String with any duplicate characters removed.
         */</span>
        <span class="keyword">function</span> <span class="function">clipDuplicates</span>(str) {
            <span class="keyword">return</span> nativ.replace.call(str, <span class="regexp"><span class="delimiter">/</span><span class="content">([</span><span class="char">\s</span><span class="char">\S</span><span class="content">])(?=[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*</span><span class="char">\1</span><span class="content">)</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>);
        }

        <span class="comment">/**
         * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`
         * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing
         * flags g and y while copying the regex.
         *
         * @private
         * @param {RegExp} regex Regex to copy.
         * @param {Object} [options] Options object with optional properties:
         *   &lt;li&gt;`addG` {Boolean} Add flag g while copying the regex.
         *   &lt;li&gt;`addY` {Boolean} Add flag y while copying the regex.
         *   &lt;li&gt;`removeG` {Boolean} Remove flag g while copying the regex.
         *   &lt;li&gt;`removeY` {Boolean} Remove flag y while copying the regex.
         *   &lt;li&gt;`isInternalOnly` {Boolean} Whether the copied regex will be used only for internal
         *     operations, and never exposed to users. For internal-only regexes, we can improve perf by
         *     skipping some operations like attaching `XRegExp.prototype` properties.
         * @returns {RegExp} Copy of the provided regex, possibly with modified flags.
         */</span>
        <span class="keyword">function</span> <span class="function">copyRegex</span>(regex, options) {
            <span class="keyword">if</span> (!XRegExp.isRegExp(regex)) {
                <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string"><span class="delimiter">'</span><span class="content">Type RegExp expected</span><span class="delimiter">'</span></span>);
            }

            <span class="keyword">var</span> xData = regex[REGEX_DATA] || {},
                flags = getNativeFlags(regex),
                flagsToAdd = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>,
                flagsToRemove = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>,
                xregexpSource = <span class="predefined-constant">null</span>,
                xregexpFlags = <span class="predefined-constant">null</span>;

            options = options || {};

            <span class="keyword">if</span> (options.removeG) {
                flagsToRemove += <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>;
            }
            <span class="keyword">if</span> (options.removeY) {
                flagsToRemove += <span class="string"><span class="delimiter">'</span><span class="content">y</span><span class="delimiter">'</span></span>;
            }
            <span class="keyword">if</span> (flagsToRemove) {
                flags = nativ.replace.call(flags, <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">[</span><span class="delimiter">'</span></span> + flagsToRemove + <span class="string"><span class="delimiter">'</span><span class="content">]+</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>), <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>);
            }

            <span class="keyword">if</span> (options.addG) {
                flagsToAdd += <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>;
            }
            <span class="keyword">if</span> (options.addY) {
                flagsToAdd += <span class="string"><span class="delimiter">'</span><span class="content">y</span><span class="delimiter">'</span></span>;
            }
            <span class="keyword">if</span> (flagsToAdd) {
                flags = clipDuplicates(flags + flagsToAdd);
            }

            <span class="keyword">if</span> (!options.isInternalOnly) {
                <span class="keyword">if</span> (xData.source !== <span class="predefined-constant">undefined</span>) {
                    xregexpSource = xData.source;
                }
                <span class="comment">// null or undefined; don't want to add to `flags` if the previous value was null, since</span>
                <span class="comment">// that indicates we're not tracking original precompilation flags</span>
                <span class="keyword">if</span> (xData.flags != <span class="predefined-constant">null</span>) {
                    <span class="comment">// Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are</span>
                    <span class="comment">// never removed for non-internal regexes, so don't need to handle it</span>
                    xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;
                }
            }

            <span class="comment">// Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to</span>
            <span class="comment">// avoid searching for special tokens. That would be wrong for regexes constructed by</span>
            <span class="comment">// `RegExp`, and unnecessary for regexes constructed by `XRegExp` because the regex has</span>
            <span class="comment">// already undergone the translation to native regex syntax</span>
            regex = augment(<span class="keyword">new</span> RegExp(regex.source, flags), hasNamedCapture(regex) ? xData.captureNames.slice(<span class="integer">0</span>) : <span class="predefined-constant">null</span>, xregexpSource, xregexpFlags, options.isInternalOnly);

            <span class="keyword">return</span> regex;
        }

        <span class="comment">/**
         * Converts hexadecimal to decimal.
         *
         * @private
         * @param {String} hex
         * @returns {Number}
         */</span>
        <span class="keyword">function</span> <span class="function">dec</span>(hex) {
            <span class="keyword">return</span> parseInt(hex, <span class="integer">16</span>);
        }

        <span class="comment">/**
         * Returns native `RegExp` flags used by a regex object.
         *
         * @private
         * @param {RegExp} regex Regex to check.
         * @returns {String} Native flags in use.
         */</span>
        <span class="keyword">function</span> <span class="function">getNativeFlags</span>(regex) {
            <span class="keyword">return</span> hasFlagsProp ? regex.flags :
            <span class="comment">// Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or</span>
            <span class="comment">// concatenation with an empty string) allows this to continue working predictably when</span>
            <span class="comment">// `XRegExp.proptotype.toString` is overriden</span>
            nativ.exec.call(<span class="regexp"><span class="delimiter">/</span><span class="content">\/</span><span class="content">([a-z]*)$</span><span class="delimiter">/</span><span class="modifier">i</span></span>, RegExp.prototype.toString.call(regex))[<span class="integer">1</span>];
        }

        <span class="comment">/**
         * Determines whether a regex has extended instance data used to track capture names.
         *
         * @private
         * @param {RegExp} regex Regex to check.
         * @returns {Boolean} Whether the regex uses named capture.
         */</span>
        <span class="keyword">function</span> <span class="function">hasNamedCapture</span>(regex) {
            <span class="keyword">return</span> !!(regex[REGEX_DATA] &amp;&amp; regex[REGEX_DATA].captureNames);
        }

        <span class="comment">/**
         * Converts decimal to hexadecimal.
         *
         * @private
         * @param {Number|String} dec
         * @returns {String}
         */</span>
        <span class="keyword">function</span> <span class="function">hex</span>(dec) {
            <span class="keyword">return</span> parseInt(dec, <span class="integer">10</span>).toString(<span class="integer">16</span>);
        }

        <span class="comment">/**
         * Returns the first index at which a given value can be found in an array.
         *
         * @private
         * @param {Array} array Array to search.
         * @param {*} value Value to locate in the array.
         * @returns {Number} Zero-based index at which the item is found, or -1.
         */</span>
        <span class="keyword">function</span> <span class="function">indexOf</span>(array, value) {
            <span class="keyword">var</span> len = array.length,
                i;

            <span class="keyword">for</span> (i = <span class="integer">0</span>; i &lt; len; ++i) {
                <span class="keyword">if</span> (array[i] === value) {
                    <span class="keyword">return</span> i;
                }
            }

            <span class="keyword">return</span> -<span class="integer">1</span>;
        }

        <span class="comment">/**
         * Determines whether a value is of the specified type, by resolving its internal [[Class]].
         *
         * @private
         * @param {*} value Object to check.
         * @param {String} type Type to check for, in TitleCase.
         * @returns {Boolean} Whether the object matches the type.
         */</span>
        <span class="keyword">function</span> <span class="function">isType</span>(value, type) {
            <span class="keyword">return</span> toString.call(value) === <span class="string"><span class="delimiter">'</span><span class="content">[object </span><span class="delimiter">'</span></span> + type + <span class="string"><span class="delimiter">'</span><span class="content">]</span><span class="delimiter">'</span></span>;
        }

        <span class="comment">/**
         * Checks whether the next nonignorable token after the specified position is a quantifier.
         *
         * @private
         * @param {String} pattern Pattern to search within.
         * @param {Number} pos Index in `pattern` to search at.
         * @param {String} flags Flags used by the pattern.
         * @returns {Boolean} Whether the next token is a quantifier.
         */</span>
        <span class="keyword">function</span> <span class="function">isQuantifierNext</span>(pattern, pos, flags) {
            <span class="keyword">return</span> nativ.test.call(flags.indexOf(<span class="string"><span class="delimiter">'</span><span class="content">x</span><span class="delimiter">'</span></span>) &gt; -<span class="integer">1</span> ?
            <span class="comment">// Ignore any leading whitespace, line comments, and inline comments</span>
            <span class="regexp"><span class="delimiter">/</span><span class="content">^(?:</span><span class="char">\s</span><span class="content">+|#.*|</span><span class="content">\(</span><span class="content">\?</span><span class="content">#[^)]*</span><span class="content">\)</span><span class="content">)*(?:[?*+]|{</span><span class="char">\d</span><span class="content">+(?:,</span><span class="char">\d</span><span class="content">*)?})</span><span class="delimiter">/</span></span> :
            <span class="comment">// Ignore any leading inline comments</span>
            <span class="regexp"><span class="delimiter">/</span><span class="content">^(?:</span><span class="content">\(</span><span class="content">\?</span><span class="content">#[^)]*</span><span class="content">\)</span><span class="content">)*(?:[?*+]|{</span><span class="char">\d</span><span class="content">+(?:,</span><span class="char">\d</span><span class="content">*)?})</span><span class="delimiter">/</span></span>, pattern.slice(pos));
        }

        <span class="comment">/**
         * Pads the provided string with as many leading zeros as needed to get to length 4. Used to produce
         * fixed-length hexadecimal values.
         *
         * @private
         * @param {String} str
         * @returns {String}
         */</span>
        <span class="keyword">function</span> <span class="function">pad4</span>(str) {
            <span class="keyword">while</span> (str.length &lt; <span class="integer">4</span>) {
                str = <span class="string"><span class="delimiter">'</span><span class="content">0</span><span class="delimiter">'</span></span> + str;
            }
            <span class="keyword">return</span> str;
        }

        <span class="comment">/**
         * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads
         * the flag preparation logic from the `XRegExp` constructor.
         *
         * @private
         * @param {String} pattern Regex pattern, possibly with a leading mode modifier.
         * @param {String} flags Any combination of flags.
         * @returns {Object} Object with properties `pattern` and `flags`.
         */</span>
        <span class="keyword">function</span> <span class="function">prepareFlags</span>(pattern, flags) {
            <span class="keyword">var</span> i;

            <span class="comment">// Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags</span>
            <span class="keyword">if</span> (clipDuplicates(flags) !== flags) {
                <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string"><span class="delimiter">'</span><span class="content">Invalid duplicate regex flag </span><span class="delimiter">'</span></span> + flags);
            }

            <span class="comment">// Strip and apply a leading mode modifier with any combination of flags except g or y</span>
            pattern = nativ.replace.call(pattern, <span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="content">\(</span><span class="content">\?</span><span class="content">([</span><span class="char">\w</span><span class="content">$]+)</span><span class="content">\)</span><span class="delimiter">/</span></span>, <span class="keyword">function</span> (<span class="predefined">$0</span>, <span class="predefined">$1</span>) {
                <span class="keyword">if</span> (nativ.test.call(<span class="regexp"><span class="delimiter">/</span><span class="content">[gy]</span><span class="delimiter">/</span></span>, <span class="predefined">$1</span>)) {
                    <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string"><span class="delimiter">'</span><span class="content">Cannot use flag g or y in mode modifier </span><span class="delimiter">'</span></span> + <span class="predefined">$0</span>);
                }
                <span class="comment">// Allow duplicate flags within the mode modifier</span>
                flags = clipDuplicates(flags + <span class="predefined">$1</span>);
                <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>;
            });

            <span class="comment">// Throw on unknown native or nonnative flags</span>
            <span class="keyword">for</span> (i = <span class="integer">0</span>; i &lt; flags.length; ++i) {
                <span class="keyword">if</span> (!registeredFlags[flags.charAt(i)]) {
                    <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string"><span class="delimiter">'</span><span class="content">Unknown regex flag </span><span class="delimiter">'</span></span> + flags.charAt(i));
                }
            }

            <span class="keyword">return</span> {
                <span class="key">pattern</span>: pattern,
                <span class="key">flags</span>: flags
            };
        }

        <span class="comment">/**
         * Prepares an options object from the given value.
         *
         * @private
         * @param {String|Object} value Value to convert to an options object.
         * @returns {Object} Options object.
         */</span>
        <span class="keyword">function</span> <span class="function">prepareOptions</span>(value) {
            <span class="keyword">var</span> options = {};

            <span class="keyword">if</span> (isType(value, <span class="string"><span class="delimiter">'</span><span class="content">String</span><span class="delimiter">'</span></span>)) {
                XRegExp.forEach(value, <span class="regexp"><span class="delimiter">/</span><span class="content">[^</span><span class="char">\s</span><span class="content">,]+</span><span class="delimiter">/</span></span>, <span class="keyword">function</span> (match) {
                    options[match] = <span class="predefined-constant">true</span>;
                });

                <span class="keyword">return</span> options;
            }

            <span class="keyword">return</span> value;
        }

        <span class="comment">/**
         * Registers a flag so it doesn't throw an 'unknown flag' error.
         *
         * @private
         * @param {String} flag Single-character flag to register.
         */</span>
        <span class="keyword">function</span> <span class="function">registerFlag</span>(flag) {
            <span class="keyword">if</span> (!<span class="regexp"><span class="delimiter">/</span><span class="content">^[</span><span class="char">\w</span><span class="content">$]$</span><span class="delimiter">/</span></span>.test(flag)) {
                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">Flag must be a single character A-Za-z0-9_$</span><span class="delimiter">'</span></span>);
            }

            registeredFlags[flag] = <span class="predefined-constant">true</span>;
        }

        <span class="comment">/**
         * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified
         * position, until a match is found.
         *
         * @private
         * @param {String} pattern Original pattern from which an XRegExp object is being built.
         * @param {String} flags Flags being used to construct the regex.
         * @param {Number} pos Position to search for tokens within `pattern`.
         * @param {Number} scope Regex scope to apply: 'default' or 'class'.
         * @param {Object} context Context object to use for token handler functions.
         * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.
         */</span>
        <span class="keyword">function</span> <span class="function">runTokens</span>(pattern, flags, pos, scope, context) {
            <span class="keyword">var</span> i = tokens.length,
                leadChar = pattern.charAt(pos),
                result = <span class="predefined-constant">null</span>,
                match,
                t;

            <span class="comment">// Run in reverse insertion order</span>
            <span class="keyword">while</span> (i--) {
                t = tokens[i];
                <span class="keyword">if</span> (t.leadChar &amp;&amp; t.leadChar !== leadChar || t.scope !== scope &amp;&amp; t.scope !== <span class="string"><span class="delimiter">'</span><span class="content">all</span><span class="delimiter">'</span></span> || t.flag &amp;&amp; flags.indexOf(t.flag) === -<span class="integer">1</span>) {
                    <span class="keyword">continue</span>;
                }

                match = XRegExp.exec(pattern, t.regex, pos, <span class="string"><span class="delimiter">'</span><span class="content">sticky</span><span class="delimiter">'</span></span>);
                <span class="keyword">if</span> (match) {
                    result = {
                        <span class="key">matchLength</span>: match[<span class="integer">0</span>].length,
                        <span class="key">output</span>: t.handler.call(context, match, scope, flags),
                        <span class="key">reparse</span>: t.reparse
                    };
                    <span class="comment">// Finished with token tests</span>
                    <span class="keyword">break</span>;
                }
            }

            <span class="keyword">return</span> result;
        }

        <span class="comment">/**
         * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to
         * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if
         * the Unicode Base addon is not available, since flag A is registered by that addon.
         *
         * @private
         * @param {Boolean} on `true` to enable; `false` to disable.
         */</span>
        <span class="keyword">function</span> <span class="function">setAstral</span>(on) {
            features.astral = on;
        }

        <span class="comment">/**
         * Enables or disables native method overrides.
         *
         * @private
         * @param {Boolean} on `true` to enable; `false` to disable.
         */</span>
        <span class="keyword">function</span> <span class="function">setNatives</span>(on) {
            RegExp.prototype.exec = (on ? fixed : nativ).exec;
            RegExp.prototype.test = (on ? fixed : nativ).test;
            String.prototype.match = (on ? fixed : nativ).match;
            String.prototype.replace = (on ? fixed : nativ).replace;
            String.prototype.split = (on ? fixed : nativ).split;

            features.natives = on;
        }

        <span class="comment">/**
         * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow
         * the ES5 abstract operation `ToObject`.
         *
         * @private
         * @param {*} value Object to check and return.
         * @returns {*} The provided object.
         */</span>
        <span class="keyword">function</span> <span class="function">toObject</span>(value) {
            <span class="comment">// null or undefined</span>
            <span class="keyword">if</span> (value == <span class="predefined-constant">null</span>) {
                <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string"><span class="delimiter">'</span><span class="content">Cannot convert null or undefined to object</span><span class="delimiter">'</span></span>);
            }

            <span class="keyword">return</span> value;
        }

        <span class="comment">/* ==============================
         * Constructor
         * ============================== */</span>

        <span class="comment">/**
         * Creates an extended regular expression object for matching text with a pattern. Differs from a
         * native regular expression in that additional syntax and flags are supported. The returned object
         * is in fact a native `RegExp` and works with all native methods.
         *
         * @class XRegExp
         * @constructor
         * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.
         * @param {String} [flags] Any combination of flags.
         *   Native flags:
         *     &lt;li&gt;`g` - global
         *     &lt;li&gt;`i` - ignore case
         *     &lt;li&gt;`m` - multiline anchors
         *     &lt;li&gt;`u` - unicode (ES6)
         *     &lt;li&gt;`y` - sticky (Firefox 3+, ES6)
         *   Additional XRegExp flags:
         *     &lt;li&gt;`n` - explicit capture
         *     &lt;li&gt;`s` - dot matches all (aka singleline)
         *     &lt;li&gt;`x` - free-spacing and line comments (aka extended)
         *     &lt;li&gt;`A` - astral (requires the Unicode Base addon)
         *   Flags cannot be provided when constructing one `RegExp` from another.
         * @returns {RegExp} Extended regular expression object.
         * @example
         *
         * // With named capture and flag x
         * XRegExp('(?&lt;year&gt;  [0-9]{4} ) -?  # year  \n\
         *          (?&lt;month&gt; [0-9]{2} ) -?  # month \n\
         *          (?&lt;day&gt;   [0-9]{2} )     # day   ', 'x');
         *
         * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)
         * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and
         * // have fresh `lastIndex` properties (set to zero).
         * XRegExp(/regex/);
         */</span>
        <span class="keyword">function</span> <span class="function">XRegExp</span>(pattern, flags) {
            <span class="keyword">var</span> context = {
                <span class="key">hasNamedCapture</span>: <span class="predefined-constant">false</span>,
                <span class="key">captureNames</span>: []
            },
                scope = defaultScope,
                output = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>,
                pos = <span class="integer">0</span>,
                result,
                token,
                generated,
                appliedPattern,
                appliedFlags;

            <span class="keyword">if</span> (XRegExp.isRegExp(pattern)) {
                <span class="keyword">if</span> (flags !== <span class="predefined-constant">undefined</span>) {
                    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string"><span class="delimiter">'</span><span class="content">Cannot supply flags when copying a RegExp</span><span class="delimiter">'</span></span>);
                }
                <span class="keyword">return</span> copyRegex(pattern);
            }

            <span class="comment">// Copy the argument behavior of `RegExp`</span>
            pattern = pattern === <span class="predefined-constant">undefined</span> ? <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span> : String(pattern);
            flags = flags === <span class="predefined-constant">undefined</span> ? <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span> : String(flags);

            <span class="keyword">if</span> (XRegExp.isInstalled(<span class="string"><span class="delimiter">'</span><span class="content">astral</span><span class="delimiter">'</span></span>) &amp;&amp; flags.indexOf(<span class="string"><span class="delimiter">'</span><span class="content">A</span><span class="delimiter">'</span></span>) === -<span class="integer">1</span>) {
                <span class="comment">// This causes an error to be thrown if the Unicode Base addon is not available</span>
                flags += <span class="string"><span class="delimiter">'</span><span class="content">A</span><span class="delimiter">'</span></span>;
            }

            <span class="keyword">if</span> (!patternCache[pattern]) {
                patternCache[pattern] = {};
            }

            <span class="keyword">if</span> (!patternCache[pattern][flags]) {
                <span class="comment">// Check for flag-related errors, and strip/apply flags in a leading mode modifier</span>
                result = prepareFlags(pattern, flags);
                appliedPattern = result.pattern;
                appliedFlags = result.flags;

                <span class="comment">// Use XRegExp's tokens to translate the pattern to a native regex pattern.</span>
                <span class="comment">// `appliedPattern.length` may change on each iteration if tokens use `reparse`</span>
                <span class="keyword">while</span> (pos &lt; appliedPattern.length) {
                    <span class="keyword">do</span> {
                        <span class="comment">// Check for custom tokens at the current position</span>
                        result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
                        <span class="comment">// If the matched token used the `reparse` option, splice its output into the</span>
                        <span class="comment">// pattern before running tokens again at the same position</span>
                        <span class="keyword">if</span> (result &amp;&amp; result.reparse) {
                            appliedPattern = appliedPattern.slice(<span class="integer">0</span>, pos) + result.output + appliedPattern.slice(pos + result.matchLength);
                        }
                    } <span class="keyword">while</span> (result &amp;&amp; result.reparse);

                    <span class="keyword">if</span> (result) {
                        output += result.output;
                        pos += result.matchLength || <span class="integer">1</span>;
                    } <span class="keyword">else</span> {
                        <span class="comment">// Get the native token at the current position</span>
                        token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, <span class="string"><span class="delimiter">'</span><span class="content">sticky</span><span class="delimiter">'</span></span>)[<span class="integer">0</span>];
                        output += token;
                        pos += token.length;
                        <span class="keyword">if</span> (token === <span class="string"><span class="delimiter">'</span><span class="content">[</span><span class="delimiter">'</span></span> &amp;&amp; scope === defaultScope) {
                            scope = classScope;
                        } <span class="keyword">else</span> <span class="keyword">if</span> (token === <span class="string"><span class="delimiter">'</span><span class="content">]</span><span class="delimiter">'</span></span> &amp;&amp; scope === classScope) {
                            scope = defaultScope;
                        }
                    }
                }

                patternCache[pattern][flags] = {
                    <span class="comment">// Cleanup token cruft: repeated `(?:)(?:)` and leading/trailing `(?:)`</span>
                    <span class="key">pattern</span>: nativ.replace.call(output, <span class="regexp"><span class="delimiter">/</span><span class="content">\(</span><span class="content">\?</span><span class="content">:</span><span class="content">\)</span><span class="content">(?:[*+?]|</span><span class="content">\{</span><span class="char">\d</span><span class="content">+(?:,</span><span class="char">\d</span><span class="content">*)?})?</span><span class="content">\?</span><span class="content">?(?=</span><span class="content">\(</span><span class="content">\?</span><span class="content">:</span><span class="content">\)</span><span class="content">)|^</span><span class="content">\(</span><span class="content">\?</span><span class="content">:</span><span class="content">\)</span><span class="content">(?:[*+?]|</span><span class="content">\{</span><span class="char">\d</span><span class="content">+(?:,</span><span class="char">\d</span><span class="content">*)?})?</span><span class="content">\?</span><span class="content">?|</span><span class="content">\(</span><span class="content">\?</span><span class="content">:</span><span class="content">\)</span><span class="content">(?:[*+?]|</span><span class="content">\{</span><span class="char">\d</span><span class="content">+(?:,</span><span class="char">\d</span><span class="content">*)?})?</span><span class="content">\?</span><span class="content">?$</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>),
                    <span class="comment">// Strip all but native flags</span>
                    <span class="key">flags</span>: nativ.replace.call(appliedFlags, <span class="regexp"><span class="delimiter">/</span><span class="content">[^gimuy]+</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>),
                    <span class="comment">// `context.captureNames` has an item for each capturing group, even if unnamed</span>
                    <span class="key">captures</span>: context.hasNamedCapture ? context.captureNames : <span class="predefined-constant">null</span>
                };
            }

            generated = patternCache[pattern][flags];
            <span class="keyword">return</span> augment(<span class="keyword">new</span> RegExp(generated.pattern, generated.flags), generated.captures, pattern, flags);
        };

        <span class="comment">// Add `RegExp.prototype` to the prototype chain</span>
        XRegExp.prototype = <span class="keyword">new</span> RegExp();

        <span class="comment">/* ==============================
         * Public properties
         * ============================== */</span>

        <span class="comment">/**
         * The XRegExp version number as a string containing three dot-separated parts. For example,
         * '2.0.0-beta-3'.
         *
         * @static
         * @memberOf XRegExp
         * @type String
         */</span>
        XRegExp.version = <span class="string"><span class="delimiter">'</span><span class="content">3.1.0-dev</span><span class="delimiter">'</span></span>;

        <span class="comment">/* ==============================
         * Public methods
         * ============================== */</span>

        <span class="comment">/**
         * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to
         * create XRegExp addons. If more than one token can match the same string, the last added wins.
         *
         * @memberOf XRegExp
         * @param {RegExp} regex Regex object that matches the new token.
         * @param {Function} handler Function that returns a new pattern string (using native regex syntax)
         *   to replace the matched token within all future XRegExp regexes. Has access to persistent
         *   properties of the regex being built, through `this`. Invoked with three arguments:
         *   &lt;li&gt;The match array, with named backreference properties.
         *   &lt;li&gt;The regex scope where the match was found: 'default' or 'class'.
         *   &lt;li&gt;The flags used by the regex, including any flags in a leading mode modifier.
         *   The handler function becomes part of the XRegExp construction process, so be careful not to
         *   construct XRegExps within the function or you will trigger infinite recursion.
         * @param {Object} [options] Options object with optional properties:
         *   &lt;li&gt;`scope` {String} Scope where the token applies: 'default', 'class', or 'all'.
         *   &lt;li&gt;`flag` {String} Single-character flag that triggers the token. This also registers the
         *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.
         *   &lt;li&gt;`optionalFlags` {String} Any custom flags checked for within the token `handler` that are
         *     not required to trigger the token. This registers the flags, to prevent XRegExp from
         *     throwing an 'unknown flag' error when any of the flags are used.
         *   &lt;li&gt;`reparse` {Boolean} Whether the `handler` function's output should not be treated as
         *     final, and instead be reparseable by other tokens (including the current token). Allows
         *     token chaining or deferring.
         *   &lt;li&gt;`leadChar` {String} Single character that occurs at the beginning of any successful match
         *     of the token (not always applicable). This doesn't change the behavior of the token unless
         *     you provide an erroneous value. However, providing it can increase the token's performance
         *     since the token can be skipped at any positions where this character doesn't appear.
         * @example
         *
         * // Basic usage: Add \a for the ALERT control code
         * XRegExp.addToken(
         *   /\\a/,
         *   function() {return '\\x07';},
         *   {scope: 'all'}
         * );
         * XRegExp('\\a[\\a-\\n]+').test('\x07\n\x07'); // -&gt; true
         *
         * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.
         * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of
         * // character classes only)
         * XRegExp.addToken(
         *   /([?*+]|{\d+(?:,\d*)?})(\??)/,
         *   function(match) {return match[1] + (match[2] ? '' : '?');},
         *   {flag: 'U'}
         * );
         * XRegExp('a+', 'U').exec('aaa')[0]; // -&gt; 'a'
         * XRegExp('a+?', 'U').exec('aaa')[0]; // -&gt; 'aaa'
         */</span>
        XRegExp.<span class="function">addToken</span> = <span class="keyword">function</span> (regex, handler, options) {
            options = options || {};
            <span class="keyword">var</span> optionalFlags = options.optionalFlags,
                i;

            <span class="keyword">if</span> (options.flag) {
                registerFlag(options.flag);
            }

            <span class="keyword">if</span> (optionalFlags) {
                optionalFlags = nativ.split.call(optionalFlags, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>);
                <span class="keyword">for</span> (i = <span class="integer">0</span>; i &lt; optionalFlags.length; ++i) {
                    registerFlag(optionalFlags[i]);
                }
            }

            <span class="comment">// Add to the private list of syntax tokens</span>
            tokens.push({
                <span class="key">regex</span>: copyRegex(regex, {
                    <span class="key">addG</span>: <span class="predefined-constant">true</span>,
                    <span class="key">addY</span>: hasNativeY,
                    <span class="key">isInternalOnly</span>: <span class="predefined-constant">true</span>
                }),
                <span class="key">handler</span>: handler,
                <span class="key">scope</span>: options.scope || defaultScope,
                <span class="key">flag</span>: options.flag,
                <span class="key">reparse</span>: options.reparse,
                <span class="key">leadChar</span>: options.leadChar
            });

            <span class="comment">// Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and</span>
            <span class="comment">// flags might now produce different results</span>
            XRegExp.cache.flush(<span class="string"><span class="delimiter">'</span><span class="content">patterns</span><span class="delimiter">'</span></span>);
        };

        <span class="comment">/**
         * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with
         * the same pattern and flag combination, the cached copy of the regex is returned.
         *
         * @memberOf XRegExp
         * @param {String} pattern Regex pattern string.
         * @param {String} [flags] Any combination of XRegExp flags.
         * @returns {RegExp} Cached XRegExp object.
         * @example
         *
         * while (match = XRegExp.cache('.', 'gs').exec(str)) {
         *   // The regex is compiled once only
         * }
         */</span>
        XRegExp.<span class="function">cache</span> = <span class="keyword">function</span> (pattern, flags) {
            <span class="keyword">if</span> (!regexCache[pattern]) {
                regexCache[pattern] = {};
            }
            <span class="keyword">return</span> regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));
        };

        <span class="comment">// Intentionally undocumented</span>
        XRegExp.cache.<span class="function">flush</span> = <span class="keyword">function</span> (cacheName) {
            <span class="keyword">if</span> (cacheName === <span class="string"><span class="delimiter">'</span><span class="content">patterns</span><span class="delimiter">'</span></span>) {
                <span class="comment">// Flush the pattern cache used by the `XRegExp` constructor</span>
                patternCache = {};
            } <span class="keyword">else</span> {
                <span class="comment">// Flush the regex cache populated by `XRegExp.cache`</span>
                regexCache = {};
            }
        };

        <span class="comment">/**
         * Escapes any regular expression metacharacters, for use when matching literal strings. The result
         * can safely be used at any point within a regex that uses any flags.
         *
         * @memberOf XRegExp
         * @param {String} str String to escape.
         * @returns {String} String with regex metacharacters escaped.
         * @example
         *
         * XRegExp.escape('Escaped? &lt;.&gt;');
         * // -&gt; 'Escaped\?\ &lt;\.&gt;'
         */</span>
        XRegExp.<span class="function">escape</span> = <span class="keyword">function</span> (str) {
            <span class="keyword">return</span> nativ.replace.call(toObject(str), <span class="regexp"><span class="delimiter">/</span><span class="content">[-[</span><span class="content">\]</span><span class="content">{}()*+?.,</span><span class="char">\\</span><span class="content">^$|#</span><span class="char">\s</span><span class="content">]</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">$&amp;</span><span class="delimiter">'</span></span>);
        };

        <span class="comment">/**
         * Executes a regex search in a specified string. Returns a match array or `null`. If the provided
         * regex uses named capture, named backreference properties are included on the match array.
         * Optional `pos` and `sticky` arguments specify the search start position, and whether the match
         * must start at the specified position only. The `lastIndex` property of the provided regex is not
         * used, but is updated for compatibility. Also fixes browser bugs compared to the native
         * `RegExp.prototype.exec` and can be used reliably cross-browser.
         *
         * @memberOf XRegExp
         * @param {String} str String to search.
         * @param {RegExp} regex Regex to search with.
         * @param {Number} [pos=0] Zero-based index at which to start the search.
         * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
         *   only. The string `'sticky'` is accepted as an alternative to `true`.
         * @returns {Array} Match array with named backreference properties, or `null`.
         * @example
         *
         * // Basic use, with named backreference
         * var match = XRegExp.exec('U+2620', XRegExp('U\\+(?&lt;hex&gt;[0-9A-F]{4})'));
         * match.hex; // -&gt; '2620'
         *
         * // With pos and sticky, in a loop
         * var pos = 2, result = [], match;
         * while (match = XRegExp.exec('&lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;5&lt;6&gt;', /&lt;(\d)&gt;/, pos, 'sticky')) {
         *   result.push(match[1]);
         *   pos = match.index + match[0].length;
         * }
         * // result -&gt; ['2', '3', '4']
         */</span>
        XRegExp.<span class="function">exec</span> = <span class="keyword">function</span> (str, regex, pos, sticky) {
            <span class="keyword">var</span> cacheKey = <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>,
                addY = <span class="predefined-constant">false</span>,
                match,
                r2;

            addY = hasNativeY &amp;&amp; !!(sticky || regex.sticky &amp;&amp; sticky !== <span class="predefined-constant">false</span>);
            <span class="keyword">if</span> (addY) {
                cacheKey += <span class="string"><span class="delimiter">'</span><span class="content">y</span><span class="delimiter">'</span></span>;
            }

            regex[REGEX_DATA] = regex[REGEX_DATA] || {};

            <span class="comment">// Shares cached copies with `XRegExp.match`/`replace`</span>
            r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
                <span class="key">addG</span>: <span class="predefined-constant">true</span>,
                <span class="key">addY</span>: addY,
                <span class="key">removeY</span>: sticky === <span class="predefined-constant">false</span>,
                <span class="key">isInternalOnly</span>: <span class="predefined-constant">true</span>
            }));

            r2.lastIndex = pos = pos || <span class="integer">0</span>;

            <span class="comment">// Fixed `exec` required for `lastIndex` fix, named backreferences, etc.</span>
            match = fixed.exec.call(r2, str);

            <span class="keyword">if</span> (sticky &amp;&amp; match &amp;&amp; match.index !== pos) {
                match = <span class="predefined-constant">null</span>;
            }

            <span class="keyword">if</span> (regex.global) {
                regex.lastIndex = match ? r2.lastIndex : <span class="integer">0</span>;
            }

            <span class="keyword">return</span> match;
        };

        <span class="comment">/**
         * Executes a provided function once per regex match. Searches always start at the beginning of the
         * string and continue until the end, regardless of the state of the regex's `global` property and
         * initial `lastIndex`.
         *
         * @memberOf XRegExp
         * @param {String} str String to search.
         * @param {RegExp} regex Regex to search with.
         * @param {Function} callback Function to execute for each match. Invoked with four arguments:
         *   &lt;li&gt;The match array, with named backreference properties.
         *   &lt;li&gt;The zero-based match index.
         *   &lt;li&gt;The string being traversed.
         *   &lt;li&gt;The regex object being used to traverse the string.
         * @example
         *
         * // Extracts every other digit from a string
         * var evens = [];
         * XRegExp.forEach('1a2345', /\d/, function(match, i) {
         *   if (i % 2) evens.push(+match[0]);
         * });
         * // evens -&gt; [2, 4]
         */</span>
        XRegExp.<span class="function">forEach</span> = <span class="keyword">function</span> (str, regex, callback) {
            <span class="keyword">var</span> pos = <span class="integer">0</span>,
                i = -<span class="integer">1</span>,
                match;

            <span class="keyword">while</span> (match = XRegExp.exec(str, regex, pos)) {
                <span class="comment">// Because `regex` is provided to `callback`, the function could use the deprecated/</span>
                <span class="comment">// nonstandard `RegExp.prototype.compile` to mutate the regex. However, since</span>
                <span class="comment">// `XRegExp.exec` doesn't use `lastIndex` to set the search position, this can't lead</span>
                <span class="comment">// to an infinite loop, at least. Actually, because of the way `XRegExp.exec` caches</span>
                <span class="comment">// globalized versions of regexes, mutating the regex will not have any effect on the</span>
                <span class="comment">// iteration or matched strings, which is a nice side effect that brings extra safety</span>
                callback(match, ++i, str, regex);

                pos = match.index + (match[<span class="integer">0</span>].length || <span class="integer">1</span>);
            }
        };

        <span class="comment">/**
         * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with
         * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native
         * regexes are not recompiled using XRegExp syntax.
         *
         * @memberOf XRegExp
         * @param {RegExp} regex Regex to globalize.
         * @returns {RegExp} Copy of the provided regex with flag `g` added.
         * @example
         *
         * var globalCopy = XRegExp.globalize(/regex/);
         * globalCopy.global; // -&gt; true
         */</span>
        XRegExp.<span class="function">globalize</span> = <span class="keyword">function</span> (regex) {
            <span class="keyword">return</span> copyRegex(regex, { <span class="key">addG</span>: <span class="predefined-constant">true</span> });
        };

        <span class="comment">/**
         * Installs optional features according to the specified options. Can be undone using
         * {@link #XRegExp.uninstall}.
         *
         * @memberOf XRegExp
         * @param {Object|String} options Options object or string.
         * @example
         *
         * // With an options object
         * XRegExp.install({
         *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)
         *   astral: true,
         *
         *   // Overrides native regex methods with fixed/extended versions that support named
         *   // backreferences and fix numerous cross-browser bugs
         *   natives: true
         * });
         *
         * // With an options string
         * XRegExp.install('astral natives');
         */</span>
        XRegExp.<span class="function">install</span> = <span class="keyword">function</span> (options) {
            options = prepareOptions(options);

            <span class="keyword">if</span> (!features.astral &amp;&amp; options.astral) {
                setAstral(<span class="predefined-constant">true</span>);
            }

            <span class="keyword">if</span> (!features.natives &amp;&amp; options.natives) {
                setNatives(<span class="predefined-constant">true</span>);
            }
        };

        <span class="comment">/**
         * Checks whether an individual optional feature is installed.
         *
         * @memberOf XRegExp
         * @param {String} feature Name of the feature to check. One of:
         *   &lt;li&gt;`natives`
         *   &lt;li&gt;`astral`
         * @returns {Boolean} Whether the feature is installed.
         * @example
         *
         * XRegExp.isInstalled('natives');
         */</span>
        XRegExp.<span class="function">isInstalled</span> = <span class="keyword">function</span> (feature) {
            <span class="keyword">return</span> !!features[feature];
        };

        <span class="comment">/**
         * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes
         * created in another frame, when `instanceof` and `constructor` checks would fail.
         *
         * @memberOf XRegExp
         * @param {*} value Object to check.
         * @returns {Boolean} Whether the object is a `RegExp` object.
         * @example
         *
         * XRegExp.isRegExp('string'); // -&gt; false
         * XRegExp.isRegExp(/regex/i); // -&gt; true
         * XRegExp.isRegExp(RegExp('^', 'm')); // -&gt; true
         * XRegExp.isRegExp(XRegExp('(?s).')); // -&gt; true
         */</span>
        XRegExp.<span class="function">isRegExp</span> = <span class="keyword">function</span> (value) {
            <span class="keyword">return</span> toString.call(value) === <span class="string"><span class="delimiter">'</span><span class="content">[object RegExp]</span><span class="delimiter">'</span></span>;
            <span class="comment">//return isType(value, 'RegExp');</span>
        };

        <span class="comment">/**
         * Returns the first matched string, or in global mode, an array containing all matched strings.
         * This is essentially a more convenient re-implementation of `String.prototype.match` that gives
         * the result types you actually want (string instead of `exec`-style array in match-first mode,
         * and an empty array instead of `null` when no matches are found in match-all mode). It also lets
         * you override flag g and ignore `lastIndex`, and fixes browser bugs.
         *
         * @memberOf XRegExp
         * @param {String} str String to search.
         * @param {RegExp} regex Regex to search with.
         * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to
         *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
         *   `scope` is 'all'.
         * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
         *   mode: Array of all matched strings, or an empty array.
         * @example
         *
         * // Match first
         * XRegExp.match('abc', /\w/); // -&gt; 'a'
         * XRegExp.match('abc', /\w/g, 'one'); // -&gt; 'a'
         * XRegExp.match('abc', /x/g, 'one'); // -&gt; null
         *
         * // Match all
         * XRegExp.match('abc', /\w/g); // -&gt; ['a', 'b', 'c']
         * XRegExp.match('abc', /\w/, 'all'); // -&gt; ['a', 'b', 'c']
         * XRegExp.match('abc', /x/, 'all'); // -&gt; []
         */</span>
        XRegExp.<span class="function">match</span> = <span class="keyword">function</span> (str, regex, scope) {
            <span class="keyword">var</span> global = regex.global &amp;&amp; scope !== <span class="string"><span class="delimiter">'</span><span class="content">one</span><span class="delimiter">'</span></span> || scope === <span class="string"><span class="delimiter">'</span><span class="content">all</span><span class="delimiter">'</span></span>,
                cacheKey = (global ? <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>) + (regex.sticky ? <span class="string"><span class="delimiter">'</span><span class="content">y</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>) || <span class="string"><span class="delimiter">'</span><span class="content">noGY</span><span class="delimiter">'</span></span>,
                result,
                r2;

            regex[REGEX_DATA] = regex[REGEX_DATA] || {};

            <span class="comment">// Shares cached copies with `XRegExp.exec`/`replace`</span>
            r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
                <span class="key">addG</span>: !!global,
                <span class="key">addY</span>: !!regex.sticky,
                <span class="key">removeG</span>: scope === <span class="string"><span class="delimiter">'</span><span class="content">one</span><span class="delimiter">'</span></span>,
                <span class="key">isInternalOnly</span>: <span class="predefined-constant">true</span>
            }));

            result = nativ.match.call(toObject(str), r2);

            <span class="keyword">if</span> (regex.global) {
                regex.lastIndex = scope === <span class="string"><span class="delimiter">'</span><span class="content">one</span><span class="delimiter">'</span></span> &amp;&amp; result ?
                <span class="comment">// Can't use `r2.lastIndex` since `r2` is nonglobal in this case</span>
                result.index + result[<span class="integer">0</span>].length : <span class="integer">0</span>;
            }

            <span class="keyword">return</span> global ? result || [] : result &amp;&amp; result[<span class="integer">0</span>];
        };

        <span class="comment">/**
         * Retrieves the matches from searching a string using a chain of regexes that successively search
         * within previous matches. The provided `chain` array can contain regexes and or objects with
         * `regex` and `backref` properties. When a backreference is specified, the named or numbered
         * backreference is passed forward to the next regex or returned.
         *
         * @memberOf XRegExp
         * @param {String} str String to search.
         * @param {Array} chain Regexes that each search for matches within preceding results.
         * @returns {Array} Matches by the last regex in the chain, or an empty array.
         * @example
         *
         * // Basic usage; matches numbers within &lt;b&gt; tags
         * XRegExp.matchChain('1 &lt;b&gt;2&lt;/b&gt; 3 &lt;b&gt;4 a 56&lt;/b&gt;', [
         *   XRegExp('(?is)&lt;b&gt;.*?&lt;/b&gt;'),
         *   /\d+/
         * ]);
         * // -&gt; ['2', '4', '56']
         *
         * // Passing forward and returning specific backreferences
         * html = '&lt;a href=&quot;http://xregexp.com/api/&quot;&gt;XRegExp&lt;/a&gt;\
         *         &lt;a href=&quot;http://www.google.com/&quot;&gt;Google&lt;/a&gt;';
         * XRegExp.matchChain(html, [
         *   {regex: /&lt;a href=&quot;([^&quot;]+)&quot;&gt;/i, backref: 1},
         *   {regex: XRegExp('(?i)^https?://(?&lt;domain&gt;[^/?#]+)'), backref: 'domain'}
         * ]);
         * // -&gt; ['xregexp.com', 'www.google.com']
         */</span>
        XRegExp.<span class="function">matchChain</span> = <span class="keyword">function</span> (str, chain) {
            <span class="keyword">return</span> <span class="keyword">function</span> <span class="function">recurseChain</span>(values, level) {
                <span class="keyword">var</span> item = chain[level].regex ? chain[level] : { <span class="key">regex</span>: chain[level] },
                    matches = [],
                    <span class="function">addMatch</span> = <span class="keyword">function</span> <span class="function">addMatch</span>(match) {
                    <span class="keyword">if</span> (item.backref) {
                        <span class="comment">/* Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold
                         * the `undefined`s for backreferences to nonparticipating capturing
                         * groups. In such cases, a `hasOwnProperty` or `in` check on its own would
                         * inappropriately throw the exception, so also check if the backreference
                         * is a number that is within the bounds of the array.
                         */</span>
                        <span class="keyword">if</span> (!(match.hasOwnProperty(item.backref) || +item.backref &lt; match.length)) {
                            <span class="keyword">throw</span> <span class="keyword">new</span> ReferenceError(<span class="string"><span class="delimiter">'</span><span class="content">Backreference to undefined group: </span><span class="delimiter">'</span></span> + item.backref);
                        }

                        matches.push(match[item.backref] || <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>);
                    } <span class="keyword">else</span> {
                        matches.push(match[<span class="integer">0</span>]);
                    }
                },
                    i;

                <span class="keyword">for</span> (i = <span class="integer">0</span>; i &lt; values.length; ++i) {
                    XRegExp.forEach(values[i], item.regex, addMatch);
                }

                <span class="keyword">return</span> level === chain.length - <span class="integer">1</span> || !matches.length ? matches : recurseChain(matches, level + <span class="integer">1</span>);
            }([str], <span class="integer">0</span>);
        };

        <span class="comment">/**
         * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string
         * or regex, and the replacement can be a string or a function to be called for each match. To
         * perform a global search and replace, use the optional `scope` argument or include flag g if using
         * a regex. Replacement strings can use `${n}` for named and numbered backreferences. Replacement
         * functions can use named backreferences via `arguments[0].name`. Also fixes browser bugs compared
         * to the native `String.prototype.replace` and can be used reliably cross-browser.
         *
         * @memberOf XRegExp
         * @param {String} str String to search.
         * @param {RegExp|String} search Search pattern to be replaced.
         * @param {String|Function} replacement Replacement string or a function invoked to create it.
         *   Replacement strings can include special replacement syntax:
         *     &lt;li&gt;$$ - Inserts a literal $ character.
         *     &lt;li&gt;$&amp;, $0 - Inserts the matched substring.
         *     &lt;li&gt;$` - Inserts the string that precedes the matched substring (left context).
         *     &lt;li&gt;$' - Inserts the string that follows the matched substring (right context).
         *     &lt;li&gt;$n, $nn - Where n/nn are digits referencing an existent capturing group, inserts
         *       backreference n/nn.
         *     &lt;li&gt;${n} - Where n is a name or any number of digits that reference an existent capturing
         *       group, inserts backreference n.
         *   Replacement functions are invoked with three or more arguments:
         *     &lt;li&gt;The matched substring (corresponds to $&amp; above). Named backreferences are accessible as
         *       properties of this first argument.
         *     &lt;li&gt;0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).
         *     &lt;li&gt;The zero-based index of the match within the total search string.
         *     &lt;li&gt;The total string being searched.
         * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not
         *   explicitly specified and using a regex with flag g, `scope` is 'all'.
         * @returns {String} New string with one or all matches replaced.
         * @example
         *
         * // Regex search, using named backreferences in replacement string
         * var name = XRegExp('(?&lt;first&gt;\\w+) (?&lt;last&gt;\\w+)');
         * XRegExp.replace('John Smith', name, '${last}, ${first}');
         * // -&gt; 'Smith, John'
         *
         * // Regex search, using named backreferences in replacement function
         * XRegExp.replace('John Smith', name, function(match) {
         *   return match.last + ', ' + match.first;
         * });
         * // -&gt; 'Smith, John'
         *
         * // String search, with replace-all
         * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');
         * // -&gt; 'XRegExp builds XRegExps'
         */</span>
        XRegExp.<span class="function">replace</span> = <span class="keyword">function</span> (str, search, replacement, scope) {
            <span class="keyword">var</span> isRegex = XRegExp.isRegExp(search),
                global = search.global &amp;&amp; scope !== <span class="string"><span class="delimiter">'</span><span class="content">one</span><span class="delimiter">'</span></span> || scope === <span class="string"><span class="delimiter">'</span><span class="content">all</span><span class="delimiter">'</span></span>,
                cacheKey = (global ? <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>) + (search.sticky ? <span class="string"><span class="delimiter">'</span><span class="content">y</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>) || <span class="string"><span class="delimiter">'</span><span class="content">noGY</span><span class="delimiter">'</span></span>,
                s2 = search,
                result;

            <span class="keyword">if</span> (isRegex) {
                search[REGEX_DATA] = search[REGEX_DATA] || {};

                <span class="comment">// Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s</span>
                <span class="comment">// `lastIndex` isn't updated *during* replacement iterations</span>
                s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {
                    <span class="key">addG</span>: !!global,
                    <span class="key">addY</span>: !!search.sticky,
                    <span class="key">removeG</span>: scope === <span class="string"><span class="delimiter">'</span><span class="content">one</span><span class="delimiter">'</span></span>,
                    <span class="key">isInternalOnly</span>: <span class="predefined-constant">true</span>
                }));
            } <span class="keyword">else</span> <span class="keyword">if</span> (global) {
                s2 = <span class="keyword">new</span> RegExp(XRegExp.escape(String(search)), <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>);
            }

            <span class="comment">// Fixed `replace` required for named backreferences, etc.</span>
            result = fixed.replace.call(toObject(str), s2, replacement);

            <span class="keyword">if</span> (isRegex &amp;&amp; search.global) {
                <span class="comment">// Fixes IE, Safari bug (last tested IE 9, Safari 5.1)</span>
                search.lastIndex = <span class="integer">0</span>;
            }

            <span class="keyword">return</span> result;
        };

        <span class="comment">/**
         * Performs batch processing of string replacements. Used like {@link #XRegExp.replace}, but
         * accepts an array of replacement details. Later replacements operate on the output of earlier
         * replacements. Replacement details are accepted as an array with a regex or string to search for,
         * the replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp
         * replacement text syntax, which supports named backreference properties via `${name}`.
         *
         * @memberOf XRegExp
         * @param {String} str String to search.
         * @param {Array} replacements Array of replacement detail arrays.
         * @returns {String} New string with all replacements.
         * @example
         *
         * str = XRegExp.replaceEach(str, [
         *   [XRegExp('(?&lt;name&gt;a)'), 'z${name}'],
         *   [/b/gi, 'y'],
         *   [/c/g, 'x', 'one'], // scope 'one' overrides /g
         *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g
         *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings
         *   [/f/g, function($0) {
         *     return $0.toUpperCase();
         *   }]
         * ]);
         */</span>
        XRegExp.<span class="function">replaceEach</span> = <span class="keyword">function</span> (str, replacements) {
            <span class="keyword">var</span> i, r;

            <span class="keyword">for</span> (i = <span class="integer">0</span>; i &lt; replacements.length; ++i) {
                r = replacements[i];
                str = XRegExp.replace(str, r[<span class="integer">0</span>], r[<span class="integer">1</span>], r[<span class="integer">2</span>]);
            }

            <span class="keyword">return</span> str;
        };

        <span class="comment">/**
         * Splits a string into an array of strings using a regex or string separator. Matches of the
         * separator are not included in the result array. However, if `separator` is a regex that contains
         * capturing groups, backreferences are spliced into the result each time `separator` is matched.
         * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
         * cross-browser.
         *
         * @memberOf XRegExp
         * @param {String} str String to split.
         * @param {RegExp|String} separator Regex or string to use for separating the string.
         * @param {Number} [limit] Maximum number of items to include in the result array.
         * @returns {Array} Array of substrings.
         * @example
         *
         * // Basic use
         * XRegExp.split('a b c', ' ');
         * // -&gt; ['a', 'b', 'c']
         *
         * // With limit
         * XRegExp.split('a b c', ' ', 2);
         * // -&gt; ['a', 'b']
         *
         * // Backreferences in result array
         * XRegExp.split('..word1..', /([a-z]+)(\d+)/i);
         * // -&gt; ['..', 'word', '1', '..']
         */</span>
        XRegExp.<span class="function">split</span> = <span class="keyword">function</span> (str, separator, limit) {
            <span class="keyword">return</span> fixed.split.call(toObject(str), separator, limit);
        };

        <span class="comment">/**
         * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and
         * `sticky` arguments specify the search start position, and whether the match must start at the
         * specified position only. The `lastIndex` property of the provided regex is not used, but is
         * updated for compatibility. Also fixes browser bugs compared to the native
         * `RegExp.prototype.test` and can be used reliably cross-browser.
         *
         * @memberOf XRegExp
         * @param {String} str String to search.
         * @param {RegExp} regex Regex to search with.
         * @param {Number} [pos=0] Zero-based index at which to start the search.
         * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
         *   only. The string `'sticky'` is accepted as an alternative to `true`.
         * @returns {Boolean} Whether the regex matched the provided value.
         * @example
         *
         * // Basic use
         * XRegExp.test('abc', /c/); // -&gt; true
         *
         * // With pos and sticky
         * XRegExp.test('abc', /c/, 0, 'sticky'); // -&gt; false
         * XRegExp.test('abc', /c/, 2, 'sticky'); // -&gt; true
         */</span>
        XRegExp.<span class="function">test</span> = <span class="keyword">function</span> (str, regex, pos, sticky) {
            <span class="comment">// Do this the easy way :-)</span>
            <span class="keyword">return</span> !!XRegExp.exec(str, regex, pos, sticky);
        };

        <span class="comment">/**
         * Uninstalls optional features according to the specified options. All optional features start out
         * uninstalled, so this is used to undo the actions of {@link #XRegExp.install}.
         *
         * @memberOf XRegExp
         * @param {Object|String} options Options object or string.
         * @example
         *
         * // With an options object
         * XRegExp.uninstall({
         *   // Disables support for astral code points in Unicode addons
         *   astral: true,
         *
         *   // Restores native regex methods
         *   natives: true
         * });
         *
         * // With an options string
         * XRegExp.uninstall('astral natives');
         */</span>
        XRegExp.<span class="function">uninstall</span> = <span class="keyword">function</span> (options) {
            options = prepareOptions(options);

            <span class="keyword">if</span> (features.astral &amp;&amp; options.astral) {
                setAstral(<span class="predefined-constant">false</span>);
            }

            <span class="keyword">if</span> (features.natives &amp;&amp; options.natives) {
                setNatives(<span class="predefined-constant">false</span>);
            }
        };

        <span class="comment">/**
         * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as
         * regex objects or strings. Metacharacters are escaped in patterns provided as strings.
         * Backreferences in provided regex objects are automatically renumbered to work correctly within
         * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the
         * `flags` argument.
         *
         * @memberOf XRegExp
         * @param {Array} patterns Regexes and strings to combine.
         * @param {String} [flags] Any combination of XRegExp flags.
         * @returns {RegExp} Union of the provided regexes and strings.
         * @example
         *
         * XRegExp.union(['a+b*c', /(dogs)\1/, /(cats)\1/], 'i');
         * // -&gt; /a\+b\*c|(dogs)\1|(cats)\2/i
         */</span>
        XRegExp.<span class="function">union</span> = <span class="keyword">function</span> (patterns, flags) {
            <span class="keyword">var</span> parts = <span class="regexp"><span class="delimiter">/</span><span class="content">(</span><span class="content">\(</span><span class="content">)(?!</span><span class="content">\?</span><span class="content">)|</span><span class="char">\\</span><span class="content">([1-9]</span><span class="char">\d</span><span class="content">*)|</span><span class="char">\\</span><span class="content">[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]|</span><span class="content">\[</span><span class="content">(?:[^</span><span class="char">\\</span><span class="content">\]</span><span class="content">]|</span><span class="char">\\</span><span class="content">[</span><span class="char">\s</span><span class="char">\S</span><span class="content">])*]</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
                output = [],
                numCaptures = <span class="integer">0</span>,
                numPriorCaptures,
                captureNames,
                pattern,
                <span class="function">rewrite</span> = <span class="keyword">function</span> <span class="function">rewrite</span>(match, paren, backref) {
                <span class="keyword">var</span> name = captureNames[numCaptures - numPriorCaptures];

                <span class="comment">// Capturing group</span>
                <span class="keyword">if</span> (paren) {
                    ++numCaptures;
                    <span class="comment">// If the current capture has a name, preserve the name</span>
                    <span class="keyword">if</span> (name) {
                        <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="content">(?&lt;</span><span class="delimiter">'</span></span> + name + <span class="string"><span class="delimiter">'</span><span class="content">&gt;</span><span class="delimiter">'</span></span>;
                    }
                    <span class="comment">// Backreference</span>
                } <span class="keyword">else</span> <span class="keyword">if</span> (backref) {
                    <span class="comment">// Rewrite the backreference</span>
                    <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="delimiter">'</span></span> + (+backref + numPriorCaptures);
                }

                <span class="keyword">return</span> match;
            },
                i;

            <span class="keyword">if</span> (!(isType(patterns, <span class="string"><span class="delimiter">'</span><span class="content">Array</span><span class="delimiter">'</span></span>) &amp;&amp; patterns.length)) {
                <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string"><span class="delimiter">'</span><span class="content">Must provide a nonempty array of patterns to merge</span><span class="delimiter">'</span></span>);
            }

            <span class="keyword">for</span> (i = <span class="integer">0</span>; i &lt; patterns.length; ++i) {
                pattern = patterns[i];

                <span class="keyword">if</span> (XRegExp.isRegExp(pattern)) {
                    numPriorCaptures = numCaptures;
                    captureNames = pattern[REGEX_DATA] &amp;&amp; pattern[REGEX_DATA].captureNames || [];

                    <span class="comment">// Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns</span>
                    <span class="comment">// are independently valid; helps keep this simple. Named captures are put back</span>
                    output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
                } <span class="keyword">else</span> {
                    output.push(XRegExp.escape(pattern));
                }
            }

            <span class="keyword">return</span> XRegExp(output.join(<span class="string"><span class="delimiter">'</span><span class="content">|</span><span class="delimiter">'</span></span>), flags);
        };

        <span class="comment">/* ==============================
         * Fixed/extended native methods
         * ============================== */</span>

        <span class="comment">/**
         * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
         * bugs in the native `RegExp.prototype.exec`. Calling `XRegExp.install('natives')` uses this to
         * override the native method. Use via `XRegExp.exec` without overriding natives.
         *
         * @private
         * @param {String} str String to search.
         * @returns {Array} Match array with named backreference properties, or `null`.
         */</span>
        fixed.<span class="function">exec</span> = <span class="keyword">function</span> (str) {
            <span class="keyword">var</span> origLastIndex = <span class="local-variable">this</span>.lastIndex,
                match = nativ.exec.apply(<span class="local-variable">this</span>, <span class="local-variable">arguments</span>),
                name,
                r2,
                i;

            <span class="keyword">if</span> (match) {
                <span class="comment">// Fix browsers whose `exec` methods don't return `undefined` for nonparticipating</span>
                <span class="comment">// capturing groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of</span>
                <span class="comment">// older IEs. IE 9 in standards mode follows the spec</span>
                <span class="keyword">if</span> (!correctExecNpcg &amp;&amp; match.length &gt; <span class="integer">1</span> &amp;&amp; indexOf(match, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>) &gt; -<span class="integer">1</span>) {
                    r2 = copyRegex(<span class="local-variable">this</span>, {
                        <span class="key">removeG</span>: <span class="predefined-constant">true</span>,
                        <span class="key">isInternalOnly</span>: <span class="predefined-constant">true</span>
                    });
                    <span class="comment">// Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed</span>
                    <span class="comment">// matching due to characters outside the match</span>
                    nativ.replace.call(String(str).slice(match.index), r2, <span class="keyword">function</span> () {
                        <span class="keyword">var</span> len = <span class="local-variable">arguments</span>.length,
                            i;
                        <span class="comment">// Skip index 0 and the last 2</span>
                        <span class="keyword">for</span> (i = <span class="integer">1</span>; i &lt; len - <span class="integer">2</span>; ++i) {
                            <span class="keyword">if</span> (<span class="local-variable">arguments</span>[i] === <span class="predefined-constant">undefined</span>) {
                                match[i] = <span class="predefined-constant">undefined</span>;
                            }
                        }
                    });
                }

                <span class="comment">// Attach named capture properties</span>
                <span class="keyword">if</span> (<span class="local-variable">this</span>[REGEX_DATA] &amp;&amp; <span class="local-variable">this</span>[REGEX_DATA].captureNames) {
                    <span class="comment">// Skip index 0</span>
                    <span class="keyword">for</span> (i = <span class="integer">1</span>; i &lt; match.length; ++i) {
                        name = <span class="local-variable">this</span>[REGEX_DATA].captureNames[i - <span class="integer">1</span>];
                        <span class="keyword">if</span> (name) {
                            match[name] = match[i];
                        }
                    }
                }

                <span class="comment">// Fix browsers that increment `lastIndex` after zero-length matches</span>
                <span class="keyword">if</span> (<span class="local-variable">this</span>.global &amp;&amp; !match[<span class="integer">0</span>].length &amp;&amp; <span class="local-variable">this</span>.lastIndex &gt; match.index) {
                    <span class="local-variable">this</span>.lastIndex = match.index;
                }
            }

            <span class="keyword">if</span> (!<span class="local-variable">this</span>.global) {
                <span class="comment">// Fixes IE, Opera bug (last tested IE 9, Opera 11.6)</span>
                <span class="local-variable">this</span>.lastIndex = origLastIndex;
            }

            <span class="keyword">return</span> match;
        };

        <span class="comment">/**
         * Fixes browser bugs in the native `RegExp.prototype.test`. Calling `XRegExp.install('natives')`
         * uses this to override the native method.
         *
         * @private
         * @param {String} str String to search.
         * @returns {Boolean} Whether the regex matched the provided value.
         */</span>
        fixed.<span class="function">test</span> = <span class="keyword">function</span> (str) {
            <span class="comment">// Do this the easy way :-)</span>
            <span class="keyword">return</span> !!fixed.exec.call(<span class="local-variable">this</span>, str);
        };

        <span class="comment">/**
         * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
         * bugs in the native `String.prototype.match`. Calling `XRegExp.install('natives')` uses this to
         * override the native method.
         *
         * @private
         * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.
         * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,
         *   the result of calling `regex.exec(this)`.
         */</span>
        fixed.<span class="function">match</span> = <span class="keyword">function</span> (regex) {
            <span class="keyword">var</span> result;

            <span class="keyword">if</span> (!XRegExp.isRegExp(regex)) {
                <span class="comment">// Use the native `RegExp` rather than `XRegExp`</span>
                regex = <span class="keyword">new</span> RegExp(regex);
            } <span class="keyword">else</span> <span class="keyword">if</span> (regex.global) {
                result = nativ.match.apply(<span class="local-variable">this</span>, <span class="local-variable">arguments</span>);
                <span class="comment">// Fixes IE bug</span>
                regex.lastIndex = <span class="integer">0</span>;

                <span class="keyword">return</span> result;
            }

            <span class="keyword">return</span> fixed.exec.call(regex, toObject(<span class="local-variable">this</span>));
        };

        <span class="comment">/**
         * Adds support for `${n}` tokens for named and numbered backreferences in replacement text, and
         * provides named backreferences to replacement functions as `arguments[0].name`. Also fixes browser
         * bugs in replacement text syntax when performing a replacement using a nonregex search value, and
         * the value of a replacement regex's `lastIndex` property during replacement iterations and upon
         * completion. Calling `XRegExp.install('natives')` uses this to override the native method. Note
         * that this doesn't support SpiderMonkey's proprietary third (`flags`) argument. Use via
         * `XRegExp.replace` without overriding natives.
         *
         * @private
         * @param {RegExp|String} search Search pattern to be replaced.
         * @param {String|Function} replacement Replacement string or a function invoked to create it.
         * @returns {String} New string with one or all matches replaced.
         */</span>
        fixed.<span class="function">replace</span> = <span class="keyword">function</span> (search, replacement) {
            <span class="keyword">var</span> isRegex = XRegExp.isRegExp(search),
                origLastIndex,
                captureNames,
                result;

            <span class="keyword">if</span> (isRegex) {
                <span class="keyword">if</span> (search[REGEX_DATA]) {
                    captureNames = search[REGEX_DATA].captureNames;
                }
                <span class="comment">// Only needed if `search` is nonglobal</span>
                origLastIndex = search.lastIndex;
            } <span class="keyword">else</span> {
                search += <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>; <span class="comment">// Type-convert</span>
            }

            <span class="comment">// Don't use `typeof`; some older browsers return 'function' for regex objects</span>
            <span class="keyword">if</span> (isType(replacement, <span class="string"><span class="delimiter">'</span><span class="content">Function</span><span class="delimiter">'</span></span>)) {
                <span class="comment">// Stringifying `this` fixes a bug in IE &lt; 9 where the last argument in replacement</span>
                <span class="comment">// functions isn't type-converted to a string</span>
                result = nativ.replace.call(String(<span class="local-variable">this</span>), search, <span class="keyword">function</span> () {
                    <span class="keyword">var</span> args = <span class="local-variable">arguments</span>,
                        i;
                    <span class="keyword">if</span> (captureNames) {
                        <span class="comment">// Change the `arguments[0]` string primitive to a `String` object that can</span>
                        <span class="comment">// store properties. This really does need to use `String` as a constructor</span>
                        args[<span class="integer">0</span>] = <span class="keyword">new</span> String(args[<span class="integer">0</span>]);
                        <span class="comment">// Store named backreferences on the first argument</span>
                        <span class="keyword">for</span> (i = <span class="integer">0</span>; i &lt; captureNames.length; ++i) {
                            <span class="keyword">if</span> (captureNames[i]) {
                                args[<span class="integer">0</span>][captureNames[i]] = args[i + <span class="integer">1</span>];
                            }
                        }
                    }
                    <span class="comment">// Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox,</span>
                    <span class="comment">// Safari bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)</span>
                    <span class="keyword">if</span> (isRegex &amp;&amp; search.global) {
                        search.lastIndex = args[args.length - <span class="integer">2</span>] + args[<span class="integer">0</span>].length;
                    }
                    <span class="comment">// ES6 specs the context for replacement functions as `undefined`</span>
                    <span class="keyword">return</span> replacement.apply(<span class="predefined-constant">undefined</span>, args);
                });
            } <span class="keyword">else</span> {
                <span class="comment">// Ensure that the last value of `args` will be a string when given nonstring `this`,</span>
                <span class="comment">// while still throwing on null or undefined context</span>
                result = nativ.replace.call(<span class="local-variable">this</span> == <span class="predefined-constant">null</span> ? <span class="local-variable">this</span> : String(<span class="local-variable">this</span>), search, <span class="keyword">function</span> () {
                    <span class="comment">// Keep this function's `arguments` available through closure</span>
                    <span class="keyword">var</span> args = <span class="local-variable">arguments</span>;
                    <span class="keyword">return</span> nativ.replace.call(String(replacement), replacementToken, <span class="keyword">function</span> (<span class="predefined">$0</span>, <span class="predefined">$1</span>, <span class="predefined">$2</span>) {
                        <span class="keyword">var</span> n;
                        <span class="comment">// Named or numbered backreference with curly braces</span>
                        <span class="keyword">if</span> (<span class="predefined">$1</span>) {
                            <span class="comment">// XRegExp behavior for `${n}`:</span>
                            <span class="comment">// 1. Backreference to numbered capture, if `n` is an integer. Use `0` for</span>
                            <span class="comment">//    for the entire match. Any number of leading zeros may be used.</span>
                            <span class="comment">// 2. Backreference to named capture `n`, if it exists and is not an</span>
                            <span class="comment">//    integer overridden by numbered capture. In practice, this does not</span>
                            <span class="comment">//    overlap with numbered capture since XRegExp does not allow named</span>
                            <span class="comment">//    capture to use a bare integer as the name.</span>
                            <span class="comment">// 3. If the name or number does not refer to an existing capturing group,</span>
                            <span class="comment">//    it's an error.</span>
                            n = +<span class="predefined">$1</span>; <span class="comment">// Type-convert; drop leading zeros</span>
                            <span class="keyword">if</span> (n &lt;= args.length - <span class="integer">3</span>) {
                                <span class="keyword">return</span> args[n] || <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>;
                            }
                            <span class="comment">// Groups with the same name is an error, else would need `lastIndexOf`</span>
                            n = captureNames ? indexOf(captureNames, <span class="predefined">$1</span>) : -<span class="integer">1</span>;
                            <span class="keyword">if</span> (n &lt; <span class="integer">0</span>) {
                                <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string"><span class="delimiter">'</span><span class="content">Backreference to undefined group </span><span class="delimiter">'</span></span> + <span class="predefined">$0</span>);
                            }
                            <span class="keyword">return</span> args[n + <span class="integer">1</span>] || <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>;
                        }
                        <span class="comment">// Else, special variable or numbered backreference without curly braces</span>
                        <span class="keyword">if</span> (<span class="predefined">$2</span> === <span class="string"><span class="delimiter">'</span><span class="content">$</span><span class="delimiter">'</span></span>) {
                            <span class="comment">// $$</span>
                            <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="content">$</span><span class="delimiter">'</span></span>;
                        }
                        <span class="keyword">if</span> (<span class="predefined">$2</span> === <span class="string"><span class="delimiter">'</span><span class="content">&amp;</span><span class="delimiter">'</span></span> || +<span class="predefined">$2</span> === <span class="integer">0</span>) {
                            <span class="comment">// $&amp;, $0 (not followed by 1-9), $00</span>
                            <span class="keyword">return</span> args[<span class="integer">0</span>];
                        }
                        <span class="keyword">if</span> (<span class="predefined">$2</span> === <span class="string"><span class="delimiter">'</span><span class="content">`</span><span class="delimiter">'</span></span>) {
                            <span class="comment">// $` (left context)</span>
                            <span class="keyword">return</span> args[args.length - <span class="integer">1</span>].slice(<span class="integer">0</span>, args[args.length - <span class="integer">2</span>]);
                        }
                        <span class="keyword">if</span> (<span class="predefined">$2</span> === <span class="string"><span class="delimiter">&quot;</span><span class="content">'</span><span class="delimiter">&quot;</span></span>) {
                            <span class="comment">// $' (right context)</span>
                            <span class="keyword">return</span> args[args.length - <span class="integer">1</span>].slice(args[args.length - <span class="integer">2</span>] + args[<span class="integer">0</span>].length);
                        }
                        <span class="comment">// Else, numbered backreference without curly braces</span>
                        <span class="predefined">$2</span> = +<span class="predefined">$2</span>; <span class="comment">// Type-convert; drop leading zero</span>
                        <span class="comment">// XRegExp behavior for `$n` and `$nn`:</span>
                        <span class="comment">// - Backrefs end after 1 or 2 digits. Use `${..}` for more digits.</span>
                        <span class="comment">// - `$1` is an error if no capturing groups.</span>
                        <span class="comment">// - `$10` is an error if less than 10 capturing groups. Use `${1}0` instead.</span>
                        <span class="comment">// - `$01` is `$1` if at least one capturing group, else it's an error.</span>
                        <span class="comment">// - `$0` (not followed by 1-9) and `$00` are the entire match.</span>
                        <span class="comment">// Native behavior, for comparison:</span>
                        <span class="comment">// - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.</span>
                        <span class="comment">// - `$1` is a literal `$1` if no capturing groups.</span>
                        <span class="comment">// - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.</span>
                        <span class="comment">// - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.</span>
                        <span class="comment">// - `$0` is a literal `$0`.</span>
                        <span class="keyword">if</span> (!isNaN(<span class="predefined">$2</span>)) {
                            <span class="keyword">if</span> (<span class="predefined">$2</span> &gt; args.length - <span class="integer">3</span>) {
                                <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string"><span class="delimiter">'</span><span class="content">Backreference to undefined group </span><span class="delimiter">'</span></span> + <span class="predefined">$0</span>);
                            }
                            <span class="keyword">return</span> args[<span class="predefined">$2</span>] || <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>;
                        }
                        <span class="comment">// `$` followed by an unsupported char is an error, unlike native JS</span>
                        <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string"><span class="delimiter">'</span><span class="content">Invalid token </span><span class="delimiter">'</span></span> + <span class="predefined">$0</span>);
                    });
                });
            }

            <span class="keyword">if</span> (isRegex) {
                <span class="keyword">if</span> (search.global) {
                    <span class="comment">// Fixes IE, Safari bug (last tested IE 9, Safari 5.1)</span>
                    search.lastIndex = <span class="integer">0</span>;
                } <span class="keyword">else</span> {
                    <span class="comment">// Fixes IE, Opera bug (last tested IE 9, Opera 11.6)</span>
                    search.lastIndex = origLastIndex;
                }
            }

            <span class="keyword">return</span> result;
        };

        <span class="comment">/**
         * Fixes browser bugs in the native `String.prototype.split`. Calling `XRegExp.install('natives')`
         * uses this to override the native method. Use via `XRegExp.split` without overriding natives.
         *
         * @private
         * @param {RegExp|String} separator Regex or string to use for separating the string.
         * @param {Number} [limit] Maximum number of items to include in the result array.
         * @returns {Array} Array of substrings.
         */</span>
        fixed.<span class="function">split</span> = <span class="keyword">function</span> (separator, limit) {
            <span class="keyword">if</span> (!XRegExp.isRegExp(separator)) {
                <span class="comment">// Browsers handle nonregex split correctly, so use the faster native method</span>
                <span class="keyword">return</span> nativ.split.apply(<span class="local-variable">this</span>, <span class="local-variable">arguments</span>);
            }

            <span class="keyword">var</span> str = String(<span class="local-variable">this</span>),
                output = [],
                origLastIndex = separator.lastIndex,
                lastLastIndex = <span class="integer">0</span>,
                lastLength;

            <span class="comment">// Values for `limit`, per the spec:</span>
            <span class="comment">// If undefined: pow(2,32) - 1</span>
            <span class="comment">// If 0, Infinity, or NaN: 0</span>
            <span class="comment">// If positive number: limit = floor(limit); if (limit &gt;= pow(2,32)) limit -= pow(2,32);</span>
            <span class="comment">// If negative number: pow(2,32) - floor(abs(limit))</span>
            <span class="comment">// If other: Type-convert, then use the above rules</span>
            <span class="comment">// This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63,</span>
            <span class="comment">// unless Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+</span>
            limit = (limit === <span class="predefined-constant">undefined</span> ? -<span class="integer">1</span> : limit) &gt;&gt;&gt; <span class="integer">0</span>;

            XRegExp.forEach(str, separator, <span class="keyword">function</span> (match) {
                <span class="comment">// This condition is not the same as `if (match[0].length)`</span>
                <span class="keyword">if</span> (match.index + match[<span class="integer">0</span>].length &gt; lastLastIndex) {
                    output.push(str.slice(lastLastIndex, match.index));
                    <span class="keyword">if</span> (match.length &gt; <span class="integer">1</span> &amp;&amp; match.index &lt; str.length) {
                        Array.prototype.push.apply(output, match.slice(<span class="integer">1</span>));
                    }
                    lastLength = match[<span class="integer">0</span>].length;
                    lastLastIndex = match.index + lastLength;
                }
            });

            <span class="keyword">if</span> (lastLastIndex === str.length) {
                <span class="keyword">if</span> (!nativ.test.call(separator, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>) || lastLength) {
                    output.push(<span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>);
                }
            } <span class="keyword">else</span> {
                output.push(str.slice(lastLastIndex));
            }

            separator.lastIndex = origLastIndex;
            <span class="keyword">return</span> output.length &gt; limit ? output.slice(<span class="integer">0</span>, limit) : output;
        };

        <span class="comment">/* ==============================
         * Built-in syntax/flag tokens
         * ============================== */</span>

        <span class="comment">/*
         * Letter escapes that natively match literal characters: `\a`, `\A`, etc. These should be
         * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser
         * consistency and to reserve their syntax, but lets them be superseded by addons.
         */</span>
        XRegExp.addToken(<span class="regexp"><span class="delimiter">/</span><span class="char">\\</span><span class="content">([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![</span><span class="char">\d</span><span class="content">A-Fa-f]{4}|{[</span><span class="char">\d</span><span class="content">A-Fa-f]+})|x(?![</span><span class="char">\d</span><span class="content">A-Fa-f]{2}))</span><span class="delimiter">/</span></span>, <span class="keyword">function</span> (match, scope) {
            <span class="comment">// \B is allowed in default scope only</span>
            <span class="keyword">if</span> (match[<span class="integer">1</span>] === <span class="string"><span class="delimiter">'</span><span class="content">B</span><span class="delimiter">'</span></span> &amp;&amp; scope === defaultScope) {
                <span class="keyword">return</span> match[<span class="integer">0</span>];
            }
            <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string"><span class="delimiter">'</span><span class="content">Invalid escape </span><span class="delimiter">'</span></span> + match[<span class="integer">0</span>]);
        }, {
            <span class="key">scope</span>: <span class="string"><span class="delimiter">'</span><span class="content">all</span><span class="delimiter">'</span></span>,
            <span class="key">leadChar</span>: <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="delimiter">'</span></span>
        });

        <span class="comment">/*
         * Unicode code point escape with curly braces: `\u{N..}`. `N..` is any one or more digit
         * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag
         * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to
         * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior
         * if you follow a `\u{N..}` token that references a code point above U+FFFF with a quantifier, or
         * if you use the same in a character class.
         */</span>
        XRegExp.addToken(<span class="regexp"><span class="delimiter">/</span><span class="char">\\</span><span class="content">u{([</span><span class="char">\d</span><span class="content">A-Fa-f]+)}</span><span class="delimiter">/</span></span>, <span class="keyword">function</span> (match, scope, flags) {
            <span class="keyword">var</span> code = dec(match[<span class="integer">1</span>]);
            <span class="keyword">if</span> (code &gt; <span class="hex">0x10FFFF</span>) {
                <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string"><span class="delimiter">'</span><span class="content">Invalid Unicode code point </span><span class="delimiter">'</span></span> + match[<span class="integer">0</span>]);
            }
            <span class="keyword">if</span> (code &lt;= <span class="hex">0xFFFF</span>) {
                <span class="comment">// Converting to \uNNNN avoids needing to escape the literal character and keep it</span>
                <span class="comment">// separate from preceding tokens</span>
                <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">u</span><span class="delimiter">'</span></span> + pad4(hex(code));
            }
            <span class="comment">// If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling</span>
            <span class="keyword">if</span> (hasNativeU &amp;&amp; flags.indexOf(<span class="string"><span class="delimiter">'</span><span class="content">u</span><span class="delimiter">'</span></span>) &gt; -<span class="integer">1</span>) {
                <span class="keyword">return</span> match[<span class="integer">0</span>];
            }
            <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string"><span class="delimiter">'</span><span class="content">Cannot use Unicode code point above </span><span class="char">\\</span><span class="content">u{FFFF} without flag u</span><span class="delimiter">'</span></span>);
        }, {
            <span class="key">scope</span>: <span class="string"><span class="delimiter">'</span><span class="content">all</span><span class="delimiter">'</span></span>,
            <span class="key">leadChar</span>: <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="delimiter">'</span></span>
        });

        <span class="comment">/*
         * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.
         * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because
         * character class endings can't be determined.
         */</span>
        XRegExp.addToken(<span class="regexp"><span class="delimiter">/</span><span class="content">\[</span><span class="content">(</span><span class="content">\^</span><span class="content">?)]</span><span class="delimiter">/</span></span>, <span class="keyword">function</span> (match) {
            <span class="comment">// For cross-browser compatibility with ES3, convert [] to \b\B and [^] to [\s\S].</span>
            <span class="comment">// (?!) should work like \b\B, but is unreliable in some versions of Firefox</span>
            <span class="keyword">return</span> match[<span class="integer">1</span>] ? <span class="string"><span class="delimiter">'</span><span class="content">[</span><span class="char">\\</span><span class="content">s</span><span class="char">\\</span><span class="content">S]</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">b</span><span class="char">\\</span><span class="content">B</span><span class="delimiter">'</span></span>;
        }, { <span class="key">leadChar</span>: <span class="string"><span class="delimiter">'</span><span class="content">[</span><span class="delimiter">'</span></span> });

        <span class="comment">/*
         * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in
         * free-spacing mode (flag x).
         */</span>
        XRegExp.addToken(<span class="regexp"><span class="delimiter">/</span><span class="content">\(</span><span class="content">\?</span><span class="content">#[^)]*</span><span class="content">\)</span><span class="delimiter">/</span></span>, <span class="keyword">function</span> (match, scope, flags) {
            <span class="comment">// Keep tokens separated unless the following token is a quantifier</span>
            <span class="keyword">return</span> isQuantifierNext(match.input, match.index + match[<span class="integer">0</span>].length, flags) ? <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="content">(?:)</span><span class="delimiter">'</span></span>;
        }, { <span class="key">leadChar</span>: <span class="string"><span class="delimiter">'</span><span class="content">(</span><span class="delimiter">'</span></span> });

        <span class="comment">/*
         * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.
         */</span>
        XRegExp.addToken(<span class="regexp"><span class="delimiter">/</span><span class="char">\s</span><span class="content">+|#.*</span><span class="delimiter">/</span></span>, <span class="keyword">function</span> (match, scope, flags) {
            <span class="comment">// Keep tokens separated unless the following token is a quantifier</span>
            <span class="keyword">return</span> isQuantifierNext(match.input, match.index + match[<span class="integer">0</span>].length, flags) ? <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="content">(?:)</span><span class="delimiter">'</span></span>;
        }, { <span class="key">flag</span>: <span class="string"><span class="delimiter">'</span><span class="content">x</span><span class="delimiter">'</span></span> });

        <span class="comment">/*
         * Dot, in dotall mode (aka singleline mode, flag s) only.
         */</span>
        XRegExp.addToken(<span class="regexp"><span class="delimiter">/</span><span class="content">\.</span><span class="delimiter">/</span></span>, <span class="keyword">function</span> () {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="content">[</span><span class="char">\\</span><span class="content">s</span><span class="char">\\</span><span class="content">S]</span><span class="delimiter">'</span></span>;
        }, {
            <span class="key">flag</span>: <span class="string"><span class="delimiter">'</span><span class="content">s</span><span class="delimiter">'</span></span>,
            <span class="key">leadChar</span>: <span class="string"><span class="delimiter">'</span><span class="content">.</span><span class="delimiter">'</span></span>
        });

        <span class="comment">/*
         * Named backreference: `\k&lt;name&gt;`. Backreference names can use the characters A-Z, a-z, 0-9, _,
         * and $ only. Also allows numbered backreferences as `\k&lt;n&gt;`.
         */</span>
        XRegExp.addToken(<span class="regexp"><span class="delimiter">/</span><span class="char">\\</span><span class="content">k&lt;([</span><span class="char">\w</span><span class="content">$]+)&gt;</span><span class="delimiter">/</span></span>, <span class="keyword">function</span> (match) {
            <span class="comment">// Groups with the same name is an error, else would need `lastIndexOf`</span>
            <span class="keyword">var</span> index = isNaN(match[<span class="integer">1</span>]) ? indexOf(<span class="local-variable">this</span>.captureNames, match[<span class="integer">1</span>]) + <span class="integer">1</span> : +match[<span class="integer">1</span>],
                endIndex = match.index + match[<span class="integer">0</span>].length;
            <span class="keyword">if</span> (!index || index &gt; <span class="local-variable">this</span>.captureNames.length) {
                <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string"><span class="delimiter">'</span><span class="content">Backreference to undefined group </span><span class="delimiter">'</span></span> + match[<span class="integer">0</span>]);
            }
            <span class="comment">// Keep backreferences separate from subsequent literal numbers</span>
            <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="delimiter">'</span></span> + index + (endIndex === match.input.length || isNaN(match.input.charAt(endIndex)) ? <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="content">(?:)</span><span class="delimiter">'</span></span>);
        }, { <span class="key">leadChar</span>: <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="delimiter">'</span></span> });

        <span class="comment">/*
         * Numbered backreference or octal, plus any following digits: `\0`, `\11`, etc. Octals except `\0`
         * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches
         * are returned unaltered. IE &lt; 9 doesn't support backreferences above `\99` in regex syntax.
         */</span>
        XRegExp.addToken(<span class="regexp"><span class="delimiter">/</span><span class="char">\\</span><span class="content">(</span><span class="char">\d</span><span class="content">+)</span><span class="delimiter">/</span></span>, <span class="keyword">function</span> (match, scope) {
            <span class="keyword">if</span> (!(scope === defaultScope &amp;&amp; <span class="regexp"><span class="delimiter">/</span><span class="content">^[1-9]</span><span class="delimiter">/</span></span>.test(match[<span class="integer">1</span>]) &amp;&amp; +match[<span class="integer">1</span>] &lt;= <span class="local-variable">this</span>.captureNames.length) &amp;&amp; match[<span class="integer">1</span>] !== <span class="string"><span class="delimiter">'</span><span class="content">0</span><span class="delimiter">'</span></span>) {
                <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string"><span class="delimiter">'</span><span class="content">Cannot use octal escape or backreference to undefined group </span><span class="delimiter">'</span></span> + match[<span class="integer">0</span>]);
            }
            <span class="keyword">return</span> match[<span class="integer">0</span>];
        }, {
            <span class="key">scope</span>: <span class="string"><span class="delimiter">'</span><span class="content">all</span><span class="delimiter">'</span></span>,
            <span class="key">leadChar</span>: <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="delimiter">'</span></span>
        });

        <span class="comment">/*
         * Named capturing group; match the opening delimiter only: `(?&lt;name&gt;`. Capture names can use the
         * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style
         * `(?P&lt;name&gt;` as an alternate syntax to avoid issues in some older versions of Opera which natively
         * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to
         * Python-style named capture as octals.
         */</span>
        XRegExp.addToken(<span class="regexp"><span class="delimiter">/</span><span class="content">\(</span><span class="content">\?</span><span class="content">P?&lt;([</span><span class="char">\w</span><span class="content">$]+)&gt;</span><span class="delimiter">/</span></span>, <span class="keyword">function</span> (match) {
            <span class="comment">// Disallow bare integers as names because named backreferences are added to match</span>
            <span class="comment">// arrays and therefore numeric properties may lead to incorrect lookups</span>
            <span class="keyword">if</span> (!isNaN(match[<span class="integer">1</span>])) {
                <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string"><span class="delimiter">'</span><span class="content">Cannot use integer as capture name </span><span class="delimiter">'</span></span> + match[<span class="integer">0</span>]);
            }
            <span class="keyword">if</span> (match[<span class="integer">1</span>] === <span class="string"><span class="delimiter">'</span><span class="content">length</span><span class="delimiter">'</span></span> || match[<span class="integer">1</span>] === <span class="string"><span class="delimiter">'</span><span class="content">__proto__</span><span class="delimiter">'</span></span>) {
                <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string"><span class="delimiter">'</span><span class="content">Cannot use reserved word as capture name </span><span class="delimiter">'</span></span> + match[<span class="integer">0</span>]);
            }
            <span class="keyword">if</span> (indexOf(<span class="local-variable">this</span>.captureNames, match[<span class="integer">1</span>]) &gt; -<span class="integer">1</span>) {
                <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string"><span class="delimiter">'</span><span class="content">Cannot use same name for multiple groups </span><span class="delimiter">'</span></span> + match[<span class="integer">0</span>]);
            }
            <span class="local-variable">this</span>.captureNames.push(match[<span class="integer">1</span>]);
            <span class="local-variable">this</span>.hasNamedCapture = <span class="predefined-constant">true</span>;
            <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="content">(</span><span class="delimiter">'</span></span>;
        }, { <span class="key">leadChar</span>: <span class="string"><span class="delimiter">'</span><span class="content">(</span><span class="delimiter">'</span></span> });

        <span class="comment">/*
         * Capturing group; match the opening parenthesis only. Required for support of named capturing
         * groups. Also adds explicit capture mode (flag n).
         */</span>
        XRegExp.addToken(<span class="regexp"><span class="delimiter">/</span><span class="content">\(</span><span class="content">(?!</span><span class="content">\?</span><span class="content">)</span><span class="delimiter">/</span></span>, <span class="keyword">function</span> (match, scope, flags) {
            <span class="keyword">if</span> (flags.indexOf(<span class="string"><span class="delimiter">'</span><span class="content">n</span><span class="delimiter">'</span></span>) &gt; -<span class="integer">1</span>) {
                <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="content">(?:</span><span class="delimiter">'</span></span>;
            }
            <span class="local-variable">this</span>.captureNames.push(<span class="predefined-constant">null</span>);
            <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="content">(</span><span class="delimiter">'</span></span>;
        }, {
            <span class="key">optionalFlags</span>: <span class="string"><span class="delimiter">'</span><span class="content">n</span><span class="delimiter">'</span></span>,
            <span class="key">leadChar</span>: <span class="string"><span class="delimiter">'</span><span class="content">(</span><span class="delimiter">'</span></span>
        });

        <span class="comment">/* ==============================
         * Expose XRegExp
         * ============================== */</span>

        module.exports = XRegExp;

<span class="comment">/***/</span> },
<span class="comment">/* 5 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        Object.defineProperty(exports, <span class="string"><span class="delimiter">&quot;</span><span class="content">__esModule</span><span class="delimiter">&quot;</span></span>, {
          <span class="key">value</span>: <span class="predefined-constant">true</span>
        });

        <span class="keyword">var</span> _match = __webpack_require__(<span class="integer">6</span>);

        Object.keys(_match).forEach(<span class="keyword">function</span> (key) {
          <span class="keyword">if</span> (key === <span class="string"><span class="delimiter">&quot;</span><span class="content">default</span><span class="delimiter">&quot;</span></span>) <span class="keyword">return</span>;
          Object.defineProperty(exports, key, {
            <span class="key">enumerable</span>: <span class="predefined-constant">true</span>,
            <span class="function">get</span>: <span class="keyword">function</span> <span class="function">get</span>() {
              <span class="keyword">return</span> _match[key];
            }
          });
        });

        <span class="keyword">var</span> _applyRegexList = __webpack_require__(<span class="integer">7</span>);

        Object.keys(_applyRegexList).forEach(<span class="keyword">function</span> (key) {
          <span class="keyword">if</span> (key === <span class="string"><span class="delimiter">&quot;</span><span class="content">default</span><span class="delimiter">&quot;</span></span>) <span class="keyword">return</span>;
          Object.defineProperty(exports, key, {
            <span class="key">enumerable</span>: <span class="predefined-constant">true</span>,
            <span class="function">get</span>: <span class="keyword">function</span> <span class="function">get</span>() {
              <span class="keyword">return</span> _applyRegexList[key];
            }
          });
        });

<span class="comment">/***/</span> },
<span class="comment">/* 6 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports) {

        <span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;

        Object.defineProperty(exports, <span class="string"><span class="delimiter">&quot;</span><span class="content">__esModule</span><span class="delimiter">&quot;</span></span>, {
          <span class="key">value</span>: <span class="predefined-constant">true</span>
        });

        <span class="keyword">var</span> <span class="function">_createClass</span> = <span class="keyword">function</span> () { <span class="keyword">function</span> <span class="function">defineProperties</span>(target, props) { <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>; i &lt; props.length; i++) { <span class="keyword">var</span> descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || <span class="predefined-constant">false</span>; descriptor.configurable = <span class="predefined-constant">true</span>; <span class="keyword">if</span> (<span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="predefined-constant">true</span>; Object.defineProperty(target, descriptor.key, descriptor); } } <span class="keyword">return</span> <span class="keyword">function</span> (Constructor, protoProps, staticProps) { <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps); <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps); <span class="keyword">return</span> Constructor; }; }();

        <span class="keyword">function</span> <span class="function">_classCallCheck</span>(instance, Constructor) { <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) { <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string"><span class="delimiter">&quot;</span><span class="content">Cannot call a class as a function</span><span class="delimiter">&quot;</span></span>); } }

        <span class="keyword">var</span> Match = exports.<span class="function">Match</span> = <span class="keyword">function</span> () {
          <span class="keyword">function</span> <span class="function">Match</span>(value, index, css) {
            _classCallCheck(<span class="local-variable">this</span>, Match);

            <span class="local-variable">this</span>.value = value;
            <span class="local-variable">this</span>.index = index;
            <span class="local-variable">this</span>.length = value.length;
            <span class="local-variable">this</span>.css = css;
            <span class="local-variable">this</span>.brushName = <span class="predefined-constant">null</span>;
          }

          _createClass(Match, [{
            <span class="key">key</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">toString</span><span class="delimiter">&quot;</span></span>,
            <span class="function">value</span>: <span class="keyword">function</span> <span class="function">toString</span>() {
              <span class="keyword">return</span> <span class="local-variable">this</span>.value;
            }
          }]);

          <span class="keyword">return</span> Match;
        }();

<span class="comment">/***/</span> },
<span class="comment">/* 7 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        Object.defineProperty(exports, <span class="string"><span class="delimiter">&quot;</span><span class="content">__esModule</span><span class="delimiter">&quot;</span></span>, {
          <span class="key">value</span>: <span class="predefined-constant">true</span>
        });

        <span class="keyword">var</span> _typeof = <span class="keyword">typeof</span> Symbol === <span class="string"><span class="delimiter">&quot;</span><span class="content">function</span><span class="delimiter">&quot;</span></span> &amp;&amp; <span class="keyword">typeof</span> Symbol.iterator === <span class="string"><span class="delimiter">&quot;</span><span class="content">symbol</span><span class="delimiter">&quot;</span></span> ? <span class="keyword">function</span> (obj) { <span class="keyword">return</span> <span class="keyword">typeof</span> obj; } : <span class="keyword">function</span> (obj) { <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> Symbol === <span class="string"><span class="delimiter">&quot;</span><span class="content">function</span><span class="delimiter">&quot;</span></span> &amp;&amp; obj.constructor === Symbol ? <span class="string"><span class="delimiter">&quot;</span><span class="content">symbol</span><span class="delimiter">&quot;</span></span> : <span class="keyword">typeof</span> obj; };

        exports.applyRegexList = applyRegexList;

        <span class="keyword">var</span> _matches = __webpack_require__(<span class="integer">8</span>);

        <span class="comment">/**
         * Applies all regular expression to the code and stores all found
         * matches in the `this.matches` array.
         */</span>
        <span class="keyword">function</span> <span class="function">applyRegexList</span>(code, regexList) {
          <span class="keyword">var</span> result = [];

          regexList = regexList || [];

          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>, l = regexList.length; i &lt; l; i++) {
            <span class="comment">// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)</span>
            <span class="keyword">if</span> (_typeof(regexList[i]) === <span class="string"><span class="delimiter">'</span><span class="content">object</span><span class="delimiter">'</span></span>) result = result.concat((<span class="integer">0</span>, _matches.find)(code, regexList[i]));
          }

          result = (<span class="integer">0</span>, _matches.sort)(result);
          result = (<span class="integer">0</span>, _matches.removeNested)(result);
          result = (<span class="integer">0</span>, _matches.compact)(result);

          <span class="keyword">return</span> result;
        }

<span class="comment">/***/</span> },
<span class="comment">/* 8 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        Object.defineProperty(exports, <span class="string"><span class="delimiter">&quot;</span><span class="content">__esModule</span><span class="delimiter">&quot;</span></span>, {
          <span class="key">value</span>: <span class="predefined-constant">true</span>
        });
        exports.find = find;
        exports.sort = sort;
        exports.compact = compact;
        exports.removeNested = removeNested;

        <span class="keyword">var</span> _match = __webpack_require__(<span class="integer">6</span>);

        <span class="keyword">var</span> _syntaxhighlighterRegex = __webpack_require__(<span class="integer">3</span>);

        <span class="comment">/**
         * Executes given regular expression on provided code and returns all matches that are found.
         *
         * @param {String} code    Code to execute regular expression on.
         * @param {Object} regex   Regular expression item info from `regexList` collection.
         * @return {Array}         Returns a list of Match objects.
         */</span>
        <span class="keyword">function</span> <span class="function">find</span>(code, regexInfo) {
          <span class="keyword">function</span> <span class="function">defaultAdd</span>(match, regexInfo) {
            <span class="keyword">return</span> match[<span class="integer">0</span>];
          };

          <span class="keyword">var</span> index = <span class="integer">0</span>,
              match = <span class="predefined-constant">null</span>,
              matches = [],
              process = regexInfo.func ? regexInfo.func : defaultAdd,
              pos = <span class="integer">0</span>;

          <span class="keyword">while</span> (match = _syntaxhighlighterRegex.XRegExp.exec(code, regexInfo.regex, pos)) {
            <span class="keyword">var</span> resultMatch = process(match, regexInfo);

            <span class="keyword">if</span> (<span class="keyword">typeof</span> resultMatch === <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>) resultMatch = [<span class="keyword">new</span> _match.Match(resultMatch, match.index, regexInfo.css)];

            matches = matches.concat(resultMatch);
            pos = match.index + match[<span class="integer">0</span>].length;
          }

          <span class="keyword">return</span> matches;
        };

        <span class="comment">/**
         * Sorts matches by index position and then by length.
         */</span>
        <span class="keyword">function</span> <span class="function">sort</span>(matches) {
          <span class="keyword">function</span> <span class="function">sortMatchesCallback</span>(m1, m2) {
            <span class="comment">// sort matches by index first</span>
            <span class="keyword">if</span> (m1.index &lt; m2.index) <span class="keyword">return</span> -<span class="integer">1</span>;<span class="keyword">else</span> <span class="keyword">if</span> (m1.index &gt; m2.index) <span class="keyword">return</span> <span class="integer">1</span>;<span class="keyword">else</span> {
              <span class="comment">// if index is the same, sort by length</span>
              <span class="keyword">if</span> (m1.length &lt; m2.length) <span class="keyword">return</span> -<span class="integer">1</span>;<span class="keyword">else</span> <span class="keyword">if</span> (m1.length &gt; m2.length) <span class="keyword">return</span> <span class="integer">1</span>;
            }

            <span class="keyword">return</span> <span class="integer">0</span>;
          }

          <span class="keyword">return</span> matches.sort(sortMatchesCallback);
        }

        <span class="keyword">function</span> <span class="function">compact</span>(matches) {
          <span class="keyword">var</span> result = [],
              i,
              l;

          <span class="keyword">for</span> (i = <span class="integer">0</span>, l = matches.length; i &lt; l; i++) {
            <span class="keyword">if</span> (matches[i]) result.push(matches[i]);
          }<span class="keyword">return</span> result;
        }

        <span class="comment">/**
         * Checks to see if any of the matches are inside of other matches.
         * This process would get rid of highligted strings inside comments,
         * keywords inside strings and so on.
         */</span>
        <span class="keyword">function</span> <span class="function">removeNested</span>(matches) {
          <span class="comment">// Optimized by Jose Prado (http://joseprado.com)</span>
          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>, l = matches.length; i &lt; l; i++) {
            <span class="keyword">if</span> (matches[i] === <span class="predefined-constant">null</span>) <span class="keyword">continue</span>;

            <span class="keyword">var</span> itemI = matches[i],
                itemIEndPos = itemI.index + itemI.length;

            <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="integer">1</span>, l = matches.length; j &lt; l &amp;&amp; matches[i] !== <span class="predefined-constant">null</span>; j++) {
              <span class="keyword">var</span> itemJ = matches[j];

              <span class="keyword">if</span> (itemJ === <span class="predefined-constant">null</span>) <span class="keyword">continue</span>;<span class="keyword">else</span> <span class="keyword">if</span> (itemJ.index &gt; itemIEndPos) <span class="keyword">break</span>;<span class="keyword">else</span> <span class="keyword">if</span> (itemJ.index == itemI.index &amp;&amp; itemJ.length &gt; itemI.length) matches[i] = <span class="predefined-constant">null</span>;<span class="keyword">else</span> <span class="keyword">if</span> (itemJ.index &gt;= itemI.index &amp;&amp; itemJ.index &lt; itemIEndPos) matches[j] = <span class="predefined-constant">null</span>;
            }
          }

          <span class="keyword">return</span> matches;
        }

<span class="comment">/***/</span> },
<span class="comment">/* 9 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        Object.defineProperty(exports, <span class="string"><span class="delimiter">&quot;</span><span class="content">__esModule</span><span class="delimiter">&quot;</span></span>, {
          <span class="key">value</span>: <span class="predefined-constant">true</span>
        });
        exports.<span class="keyword">default</span> = Renderer;
        <span class="comment">/**
         * Pads number with zeros until it's length is the same as given length.
         *
         * @param {Number} number Number to pad.
         * @param {Number} length Max string length with.
         * @return {String}     Returns a string padded with proper amount of '0'.
         */</span>
        <span class="keyword">function</span> <span class="function">padNumber</span>(number, length) {
          <span class="keyword">var</span> result = number.toString();

          <span class="keyword">while</span> (result.length &lt; length) {
            result = <span class="string"><span class="delimiter">'</span><span class="content">0</span><span class="delimiter">'</span></span> + result;
          }<span class="keyword">return</span> result;
        };

        <span class="keyword">function</span> <span class="function">getLines</span>(str) {
          <span class="keyword">return</span> str.split(<span class="regexp"><span class="delimiter">/</span><span class="char">\r</span><span class="content">?</span><span class="char">\n</span><span class="delimiter">/</span></span>);
        }

        <span class="keyword">function</span> <span class="function">getLinesToHighlight</span>(opts) {
          <span class="keyword">var</span> results = {},
              linesToHighlight,
              l,
              i;

          linesToHighlight = opts.highlight || [];

          <span class="keyword">if</span> (<span class="keyword">typeof</span> linesToHighlight.push !== <span class="string"><span class="delimiter">'</span><span class="content">function</span><span class="delimiter">'</span></span>) linesToHighlight = [linesToHighlight];

          <span class="keyword">for</span> (i = <span class="integer">0</span>, l = linesToHighlight.length; i &lt; l; i++) {
            results[linesToHighlight[i]] = <span class="predefined-constant">true</span>;
          }<span class="keyword">return</span> results;
        }

        <span class="keyword">function</span> <span class="function">Renderer</span>(code, matches, opts) {
          <span class="keyword">var</span> _this = <span class="local-variable">this</span>;

          _this.opts = opts;
          _this.code = code;
          _this.matches = matches;
          _this.lines = getLines(code);
          _this.linesToHighlight = getLinesToHighlight(opts);
        }

        Renderer.prototype = {
          <span class="comment">/**
           * Wraps each line of the string into &lt;code/&gt; tag with given style applied to it.
           *
           * @param {String} str   Input string.
           * @param {String} css   Style name to apply to the string.
           * @return {String}      Returns input string with each line surrounded by &lt;span/&gt; tag.
           */</span>
          <span class="function">wrapLinesWithCode</span>: <span class="keyword">function</span> <span class="function">wrapLinesWithCode</span>(str, css) {
            <span class="keyword">if</span> (str == <span class="predefined-constant">null</span> || str.length == <span class="integer">0</span> || str == <span class="string"><span class="delimiter">'</span><span class="content">\n</span><span class="delimiter">'</span></span> || css == <span class="predefined-constant">null</span>) <span class="keyword">return</span> str;

            <span class="keyword">var</span> _this = <span class="local-variable">this</span>,
                results = [],
                lines,
                line,
                spaces,
                i,
                l;

            str = str.replace(<span class="regexp"><span class="delimiter">/</span><span class="content">&lt;</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">&amp;lt;</span><span class="delimiter">'</span></span>);

            <span class="comment">// Replace two or more sequential spaces with &amp;nbsp; leaving last space untouched.</span>
            str = str.replace(<span class="regexp"><span class="delimiter">/</span><span class="content"> {2,}</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="keyword">function</span> (m) {
              spaces = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>;

              <span class="keyword">for</span> (i = <span class="integer">0</span>, l = m.length; i &lt; l - <span class="integer">1</span>; i++) {
                spaces += _this.opts.space;
              }<span class="keyword">return</span> spaces + <span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span>;
            });

            lines = getLines(str);

            <span class="comment">// Split each line and apply &lt;span class=&quot;...&quot;&gt;...&lt;/span&gt; to them so that leading spaces aren't included.</span>
            <span class="keyword">for</span> (i = <span class="integer">0</span>, l = lines.length; i &lt; l; i++) {
              line = lines[i];
              spaces = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>;

              <span class="keyword">if</span> (line.length &gt; <span class="integer">0</span>) {
                line = line.replace(<span class="regexp"><span class="delimiter">/</span><span class="content">^(&amp;nbsp;| )+</span><span class="delimiter">/</span></span>, <span class="keyword">function</span> (s) {
                  spaces = s;
                  <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>;
                });

                line = line.length === <span class="integer">0</span> ? spaces : spaces + <span class="string"><span class="delimiter">'</span><span class="content">&lt;code class=&quot;</span><span class="delimiter">'</span></span> + css + <span class="string"><span class="delimiter">'</span><span class="content">&quot;&gt;</span><span class="delimiter">'</span></span> + line + <span class="string"><span class="delimiter">'</span><span class="content">&lt;/code&gt;</span><span class="delimiter">'</span></span>;
              }

              results.push(line);
            }

            <span class="keyword">return</span> results.join(<span class="string"><span class="delimiter">'</span><span class="content">\n</span><span class="delimiter">'</span></span>);
          },

          <span class="comment">/**
           * Turns all URLs in the code into &lt;a/&gt; tags.
           * @param {String} code Input code.
           * @return {String} Returns code with &lt;/a&gt; tags.
           */</span>
          <span class="function">processUrls</span>: <span class="keyword">function</span> <span class="function">processUrls</span>(code) {
            <span class="keyword">var</span> gt = <span class="regexp"><span class="delimiter">/</span><span class="content">(.*)((&amp;gt;|&amp;lt;).*)</span><span class="delimiter">/</span></span>,
                url = <span class="regexp"><span class="delimiter">/</span><span class="char">\w</span><span class="content">+:</span><span class="content">\/</span><span class="content">\/</span><span class="content">[</span><span class="char">\w</span><span class="content">-.</span><span class="content">\/</span><span class="content">?%&amp;=:@;#]*</span><span class="delimiter">/</span><span class="modifier">g</span></span>;

            <span class="keyword">return</span> code.replace(url, <span class="keyword">function</span> (m) {
              <span class="keyword">var</span> suffix = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>,
                  match = <span class="predefined-constant">null</span>;

              <span class="comment">// We include &amp;lt; and &amp;gt; in the URL for the common cases like &lt;http://google.com&gt;</span>
              <span class="comment">// The problem is that they get transformed into &amp;lt;http://google.com&amp;gt;</span>
              <span class="comment">// Where as &amp;gt; easily looks like part of the URL string.</span>

              <span class="keyword">if</span> (match = gt.exec(m)) {
                m = match[<span class="integer">1</span>];
                suffix = match[<span class="integer">2</span>];
              }

              <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="content">&lt;a href=&quot;</span><span class="delimiter">'</span></span> + m + <span class="string"><span class="delimiter">'</span><span class="content">&quot;&gt;</span><span class="delimiter">'</span></span> + m + <span class="string"><span class="delimiter">'</span><span class="content">&lt;/a&gt;</span><span class="delimiter">'</span></span> + suffix;
            });
          },

          <span class="comment">/**
           * Creates an array containing integer line numbers starting from the 'first-line' param.
           * @return {Array} Returns array of integers.
           */</span>
          <span class="function">figureOutLineNumbers</span>: <span class="keyword">function</span> <span class="function">figureOutLineNumbers</span>(code) {
            <span class="keyword">var</span> lineNumbers = [],
                lines = <span class="local-variable">this</span>.lines,
                firstLine = parseInt(<span class="local-variable">this</span>.opts.firstLine || <span class="integer">1</span>),
                i,
                l;

            <span class="keyword">for</span> (i = <span class="integer">0</span>, l = lines.length; i &lt; l; i++) {
              lineNumbers.push(i + firstLine);
            }<span class="keyword">return</span> lineNumbers;
          },

          <span class="comment">/**
           * Generates HTML markup for a single line of code while determining alternating line style.
           * @param {Integer} lineNumber  Line number.
           * @param {String} code Line  HTML markup.
           * @return {String}       Returns HTML markup.
           */</span>
          <span class="function">wrapLine</span>: <span class="keyword">function</span> <span class="function">wrapLine</span>(lineIndex, lineNumber, lineHtml) {
            <span class="keyword">var</span> classes = [<span class="string"><span class="delimiter">'</span><span class="content">line</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">number</span><span class="delimiter">'</span></span> + lineNumber, <span class="string"><span class="delimiter">'</span><span class="content">index</span><span class="delimiter">'</span></span> + lineIndex, <span class="string"><span class="delimiter">'</span><span class="content">alt</span><span class="delimiter">'</span></span> + (lineNumber % <span class="integer">2</span> == <span class="integer">0</span> ? <span class="integer">1</span> : <span class="integer">2</span>).toString()];

            <span class="keyword">if</span> (<span class="local-variable">this</span>.linesToHighlight[lineNumber]) classes.push(<span class="string"><span class="delimiter">'</span><span class="content">highlighted</span><span class="delimiter">'</span></span>);

            <span class="keyword">if</span> (lineNumber == <span class="integer">0</span>) classes.push(<span class="string"><span class="delimiter">'</span><span class="content">break</span><span class="delimiter">'</span></span>);

            <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="content">&lt;div class=&quot;</span><span class="delimiter">'</span></span> + classes.join(<span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content">&quot;&gt;</span><span class="delimiter">'</span></span> + lineHtml + <span class="string"><span class="delimiter">'</span><span class="content">&lt;/div&gt;</span><span class="delimiter">'</span></span>;
          },

          <span class="comment">/**
           * Generates HTML markup for line number column.
           * @param {String} code     Complete code HTML markup.
           * @param {Array} lineNumbers Calculated line numbers.
           * @return {String}       Returns HTML markup.
           */</span>
          <span class="function">renderLineNumbers</span>: <span class="keyword">function</span> <span class="function">renderLineNumbers</span>(code, lineNumbers) {
            <span class="keyword">var</span> _this = <span class="local-variable">this</span>,
                opts = _this.opts,
                html = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>,
                count = _this.lines.length,
                firstLine = parseInt(opts.firstLine || <span class="integer">1</span>),
                pad = opts.padLineNumbers,
                lineNumber,
                i;

            <span class="keyword">if</span> (pad == <span class="predefined-constant">true</span>) pad = (firstLine + count - <span class="integer">1</span>).toString().length;<span class="keyword">else</span> <span class="keyword">if</span> (isNaN(pad) == <span class="predefined-constant">true</span>) pad = <span class="integer">0</span>;

            <span class="keyword">for</span> (i = <span class="integer">0</span>; i &lt; count; i++) {
              lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
              code = lineNumber == <span class="integer">0</span> ? opts.space : padNumber(lineNumber, pad);
              html += _this.wrapLine(i, lineNumber, code);
            }

            <span class="keyword">return</span> html;
          },

          <span class="comment">/**
           * Splits block of text into individual DIV lines.
           * @param {String} code     Code to highlight.
           * @param {Array} lineNumbers Calculated line numbers.
           * @return {String}       Returns highlighted code in HTML form.
           */</span>
          <span class="function">getCodeLinesHtml</span>: <span class="keyword">function</span> <span class="function">getCodeLinesHtml</span>(html, lineNumbers) {
            <span class="comment">// html = utils.trim(html);</span>

            <span class="keyword">var</span> _this = <span class="local-variable">this</span>,
                opts = _this.opts,
                lines = getLines(html),
                padLength = opts.padLineNumbers,
                firstLine = parseInt(opts.firstLine || <span class="integer">1</span>),
                brushName = opts.brush,
                html = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>;

            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>, l = lines.length; i &lt; l; i++) {
              <span class="keyword">var</span> line = lines[i],
                  indent = <span class="regexp"><span class="delimiter">/</span><span class="content">^(&amp;nbsp;|</span><span class="char">\s</span><span class="content">)+</span><span class="delimiter">/</span></span>.exec(line),
                  spaces = <span class="predefined-constant">null</span>,
                  lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
              ;

              <span class="keyword">if</span> (indent != <span class="predefined-constant">null</span>) {
                spaces = indent[<span class="integer">0</span>].toString();
                line = line.substr(spaces.length);
                spaces = spaces.replace(<span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span>, opts.space);
              }

              <span class="comment">// line = utils.trim(line);</span>

              <span class="keyword">if</span> (line.length == <span class="integer">0</span>) line = opts.space;

              html += _this.wrapLine(i, lineNumber, (spaces != <span class="predefined-constant">null</span> ? <span class="string"><span class="delimiter">'</span><span class="content">&lt;code class=&quot;</span><span class="delimiter">'</span></span> + brushName + <span class="string"><span class="delimiter">'</span><span class="content"> spaces&quot;&gt;</span><span class="delimiter">'</span></span> + spaces + <span class="string"><span class="delimiter">'</span><span class="content">&lt;/code&gt;</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>) + line);
            }

            <span class="keyword">return</span> html;
          },

          <span class="comment">/**
           * Returns HTML for the table title or empty string if title is null.
           */</span>
          <span class="function">getTitleHtml</span>: <span class="keyword">function</span> <span class="function">getTitleHtml</span>(title) {
            <span class="keyword">return</span> title ? <span class="string"><span class="delimiter">'</span><span class="content">&lt;caption&gt;</span><span class="delimiter">'</span></span> + title + <span class="string"><span class="delimiter">'</span><span class="content">&lt;/caption&gt;</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>;
          },

          <span class="comment">/**
           * Finds all matches in the source code.
           * @param {String} code   Source code to process matches in.
           * @param {Array} matches Discovered regex matches.
           * @return {String} Returns formatted HTML with processed mathes.
           */</span>
          <span class="function">getMatchesHtml</span>: <span class="keyword">function</span> <span class="function">getMatchesHtml</span>(code, matches) {
            <span class="keyword">function</span> <span class="function">getBrushNameCss</span>(match) {
              <span class="keyword">var</span> result = match ? match.brushName || brushName : brushName;
              <span class="keyword">return</span> result ? result + <span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>;
            };

            <span class="keyword">var</span> _this = <span class="local-variable">this</span>,
                pos = <span class="integer">0</span>,
                result = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>,
                brushName = _this.opts.brush || <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>,
                match,
                matchBrushName,
                i,
                l;

            <span class="comment">// Finally, go through the final list of matches and pull the all</span>
            <span class="comment">// together adding everything in between that isn't a match.</span>
            <span class="keyword">for</span> (i = <span class="integer">0</span>, l = matches.length; i &lt; l; i++) {
              match = matches[i];

              <span class="keyword">if</span> (match === <span class="predefined-constant">null</span> || match.length === <span class="integer">0</span>) <span class="keyword">continue</span>;

              matchBrushName = getBrushNameCss(match);

              result += _this.wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + <span class="string"><span class="delimiter">'</span><span class="content">plain</span><span class="delimiter">'</span></span>) + _this.wrapLinesWithCode(match.value, matchBrushName + match.css);

              pos = match.index + match.length + (match.offset || <span class="integer">0</span>);
            }

            <span class="comment">// don't forget to add whatever's remaining in the string</span>
            result += _this.wrapLinesWithCode(code.substr(pos), getBrushNameCss() + <span class="string"><span class="delimiter">'</span><span class="content">plain</span><span class="delimiter">'</span></span>);

            <span class="keyword">return</span> result;
          },

          <span class="comment">/**
           * Generates HTML markup for the whole syntax highlighter.
           * @param {String} code Source code.
           * @return {String} Returns HTML markup.
           */</span>
          <span class="function">getHtml</span>: <span class="keyword">function</span> <span class="function">getHtml</span>() {
            <span class="keyword">var</span> _this = <span class="local-variable">this</span>,
                opts = _this.opts,
                code = _this.code,
                matches = _this.matches,
                classes = [<span class="string"><span class="delimiter">'</span><span class="content">syntaxhighlighter</span><span class="delimiter">'</span></span>],
                lineNumbers,
                gutter,
                html;

            <span class="keyword">if</span> (opts.collapse === <span class="predefined-constant">true</span>) classes.push(<span class="string"><span class="delimiter">'</span><span class="content">collapsed</span><span class="delimiter">'</span></span>);

            gutter = opts.gutter !== <span class="predefined-constant">false</span>;

            <span class="keyword">if</span> (!gutter) classes.push(<span class="string"><span class="delimiter">'</span><span class="content">nogutter</span><span class="delimiter">'</span></span>);

            <span class="comment">// add custom user style name</span>
            classes.push(opts.className);

            <span class="comment">// add brush alias to the class name for custom CSS</span>
            classes.push(opts.brush);

            <span class="keyword">if</span> (gutter) lineNumbers = _this.figureOutLineNumbers(code);

            <span class="comment">// processes found matches into the html</span>
            html = _this.getMatchesHtml(code, matches);

            <span class="comment">// finally, split all lines so that they wrap well</span>
            html = _this.getCodeLinesHtml(html, lineNumbers);

            <span class="comment">// finally, process the links</span>
            <span class="keyword">if</span> (opts.autoLinks) html = _this.processUrls(html);

            html = <span class="string"><span class="delimiter">'</span><span class="content">\n</span><span class="content">      &lt;div class=&quot;</span><span class="delimiter">'</span></span> + classes.join(<span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content">&quot;&gt;</span><span class="content">\n</span><span class="content">        &lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;</span><span class="content">\n</span><span class="content">          </span><span class="delimiter">'</span></span> + _this.getTitleHtml(opts.title) + <span class="string"><span class="delimiter">'</span><span class="content">\n</span><span class="content">          &lt;tbody&gt;</span><span class="content">\n</span><span class="content">            &lt;tr&gt;</span><span class="content">\n</span><span class="content">              </span><span class="delimiter">'</span></span> + (gutter ? <span class="string"><span class="delimiter">'</span><span class="content">&lt;td class=&quot;gutter&quot;&gt;</span><span class="delimiter">'</span></span> + _this.renderLineNumbers(code) + <span class="string"><span class="delimiter">'</span><span class="content">&lt;/td&gt;</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content">\n</span><span class="content">              &lt;td class=&quot;code&quot;&gt;</span><span class="content">\n</span><span class="content">                &lt;div class=&quot;container&quot;&gt;</span><span class="delimiter">'</span></span> + html + <span class="string"><span class="delimiter">'</span><span class="content">&lt;/div&gt;</span><span class="content">\n</span><span class="content">              &lt;/td&gt;</span><span class="content">\n</span><span class="content">            &lt;/tr&gt;</span><span class="content">\n</span><span class="content">          &lt;/tbody&gt;</span><span class="content">\n</span><span class="content">        &lt;/table&gt;</span><span class="content">\n</span><span class="content">      &lt;/div&gt;</span><span class="content">\n</span><span class="content">    </span><span class="delimiter">'</span></span>;

            <span class="keyword">return</span> html;
          }
        };

<span class="comment">/***/</span> },
<span class="comment">/* 10 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="comment">/**
         * Splits block of text into lines.
         * @param {String} block Block of text.
         * @return {Array} Returns array of lines.
         */</span>
        <span class="keyword">function</span> <span class="function">splitLines</span>(block) {
          <span class="keyword">return</span> block.split(<span class="regexp"><span class="delimiter">/</span><span class="char">\r</span><span class="content">?</span><span class="char">\n</span><span class="delimiter">/</span></span>);
        }

        <span class="comment">/**
         * Executes a callback on each line and replaces each line with result from the callback.
         * @param {Object} str      Input string.
         * @param {Object} callback   Callback function taking one string argument and returning a string.
         */</span>
        <span class="keyword">function</span> <span class="function">eachLine</span>(str, callback) {
          <span class="keyword">var</span> lines = splitLines(str);

          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>, l = lines.length; i &lt; l; i++) {
            lines[i] = callback(lines[i], i);
          }<span class="keyword">return</span> lines.join(<span class="string"><span class="delimiter">'</span><span class="content">\n</span><span class="delimiter">'</span></span>);
        }

        <span class="comment">/**
         * Generates a unique element ID.
         */</span>
        <span class="keyword">function</span> <span class="function">guid</span>(prefix) {
          <span class="keyword">return</span> (prefix || <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>) + Math.round(Math.random() * <span class="integer">1000000</span>).toString();
        }

        <span class="comment">/**
         * Merges two objects. Values from obj2 override values in obj1.
         * Function is NOT recursive and works only for one dimensional objects.
         * @param {Object} obj1 First object.
         * @param {Object} obj2 Second object.
         * @return {Object} Returns combination of both objects.
         */</span>
        <span class="keyword">function</span> <span class="function">merge</span>(obj1, obj2) {
          <span class="keyword">var</span> result = {},
              name;

          <span class="keyword">for</span> (name <span class="keyword">in</span> obj1) {
            result[name] = obj1[name];
          }<span class="keyword">for</span> (name <span class="keyword">in</span> obj2) {
            result[name] = obj2[name];
          }<span class="keyword">return</span> result;
        }

        <span class="comment">/**
         * Removes all white space at the begining and end of a string.
         *
         * @param {String} str   String to trim.
         * @return {String}      Returns string without leading and following white space characters.
         */</span>
        <span class="keyword">function</span> <span class="function">trim</span>(str) {
          <span class="keyword">return</span> str.replace(<span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="char">\s</span><span class="content">+|</span><span class="char">\s</span><span class="content">+$</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>);
        }

        <span class="comment">/**
         * Converts the source to array object. Mostly used for function arguments and
         * lists returned by getElementsByTagName() which aren't Array objects.
         * @param {List} source Source list.
         * @return {Array} Returns array.
         */</span>
        <span class="keyword">function</span> <span class="function">toArray</span>(source) {
          <span class="keyword">return</span> Array.prototype.slice.apply(source);
        }

        <span class="comment">/**
         * Attempts to convert string to boolean.
         * @param {String} value Input string.
         * @return {Boolean} Returns true if input was &quot;true&quot;, false if input was &quot;false&quot; and value otherwise.
         */</span>
        <span class="keyword">function</span> <span class="function">toBoolean</span>(value) {
          <span class="keyword">var</span> result = { <span class="key"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>: <span class="predefined-constant">true</span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span>: <span class="predefined-constant">false</span> }[value];
          <span class="keyword">return</span> result == <span class="predefined-constant">null</span> ? value : result;
        }

        module.exports = {
          <span class="key">splitLines</span>: splitLines,
          <span class="key">eachLine</span>: eachLine,
          <span class="key">guid</span>: guid,
          <span class="key">merge</span>: merge,
          <span class="key">trim</span>: trim,
          <span class="key">toArray</span>: toArray,
          <span class="key">toBoolean</span>: toBoolean
        };

<span class="comment">/***/</span> },
<span class="comment">/* 11 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> trim = __webpack_require__(<span class="integer">12</span>),
            bloggerMode = __webpack_require__(<span class="integer">13</span>),
            stripBrs = __webpack_require__(<span class="integer">14</span>),
            unindenter = __webpack_require__(<span class="integer">15</span>),
            retabber = __webpack_require__(<span class="integer">16</span>);

        module.<span class="function">exports</span> = <span class="keyword">function</span> (code, opts) {
          code = trim(code, opts);
          code = bloggerMode(code, opts);
          code = stripBrs(code, opts);
          code = unindenter.unindent(code, opts);

          <span class="keyword">var</span> tabSize = opts[<span class="string"><span class="delimiter">'</span><span class="content">tab-size</span><span class="delimiter">'</span></span>];
          code = opts[<span class="string"><span class="delimiter">'</span><span class="content">smart-tabs</span><span class="delimiter">'</span></span>] === <span class="predefined-constant">true</span> ? retabber.smart(code, tabSize) : retabber.regular(code, tabSize);

          <span class="keyword">return</span> code;
        };

<span class="comment">/***/</span> },
<span class="comment">/* 12 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        module.<span class="function">exports</span> = <span class="keyword">function</span> (code, opts) {
           <span class="keyword">return</span> code
           <span class="comment">// This is a special trim which only removes first and last empty lines</span>
           <span class="comment">// and doesn't affect valid leading space on the first line.</span>
           .replace(<span class="regexp"><span class="delimiter">/</span><span class="content">^[ ]*[</span><span class="char">\n</span><span class="content">]+|[</span><span class="char">\n</span><span class="content">]*[ ]*$</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>)

           <span class="comment">// IE lets these buggers through</span>
           .replace(<span class="regexp"><span class="delimiter">/</span><span class="char">\r</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span>);
        };

<span class="comment">/***/</span> },
<span class="comment">/* 13 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        module.<span class="function">exports</span> = <span class="keyword">function</span> (code, opts) {
          <span class="keyword">var</span> br = <span class="regexp"><span class="delimiter">/</span><span class="content">&lt;br</span><span class="char">\s</span><span class="content">*</span><span class="content">\/</span><span class="content">?&gt;|&amp;lt;br</span><span class="char">\s</span><span class="content">*</span><span class="content">\/</span><span class="content">?&amp;gt;</span><span class="delimiter">/</span><span class="modifier">gi</span></span>;

          <span class="keyword">if</span> (opts[<span class="string"><span class="delimiter">'</span><span class="content">bloggerMode</span><span class="delimiter">'</span></span>] === <span class="predefined-constant">true</span>) code = code.replace(br, <span class="string"><span class="delimiter">'</span><span class="content">\n</span><span class="delimiter">'</span></span>);

          <span class="keyword">return</span> code;
        };

<span class="comment">/***/</span> },
<span class="comment">/* 14 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        module.<span class="function">exports</span> = <span class="keyword">function</span> (code, opts) {
          <span class="keyword">var</span> br = <span class="regexp"><span class="delimiter">/</span><span class="content">&lt;br</span><span class="char">\s</span><span class="content">*</span><span class="content">\/</span><span class="content">?&gt;|&amp;lt;br</span><span class="char">\s</span><span class="content">*</span><span class="content">\/</span><span class="content">?&amp;gt;</span><span class="delimiter">/</span><span class="modifier">gi</span></span>;

          <span class="keyword">if</span> (opts[<span class="string"><span class="delimiter">'</span><span class="content">stripBrs</span><span class="delimiter">'</span></span>] === <span class="predefined-constant">true</span>) code = code.replace(br, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>);

          <span class="keyword">return</span> code;
        };

<span class="comment">/***/</span> },
<span class="comment">/* 15 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">function</span> <span class="function">isEmpty</span>(str) {
          <span class="keyword">return</span> (<span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="char">\s</span><span class="content">*$</span><span class="delimiter">/</span></span>.test(str)
          );
        }

        module.exports = {
          <span class="function">unindent</span>: <span class="keyword">function</span> <span class="function">unindent</span>(code) {
            <span class="keyword">var</span> lines = code.split(<span class="regexp"><span class="delimiter">/</span><span class="char">\r</span><span class="content">?</span><span class="char">\n</span><span class="delimiter">/</span></span>),
                regex = <span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="char">\s</span><span class="content">*</span><span class="delimiter">/</span></span>,
                min = <span class="integer">1000</span>,
                line,
                matches,
                i,
                l;

            <span class="comment">// go through every line and check for common number of indents</span>
            <span class="keyword">for</span> (i = <span class="integer">0</span>, l = lines.length; i &lt; l &amp;&amp; min &gt; <span class="integer">0</span>; i++) {
              line = lines[i];

              <span class="keyword">if</span> (isEmpty(line)) <span class="keyword">continue</span>;

              matches = regex.exec(line);

              <span class="comment">// In the event that just one line doesn't have leading white space</span>
              <span class="comment">// we can't unindent anything, so bail completely.</span>
              <span class="keyword">if</span> (matches == <span class="predefined-constant">null</span>) <span class="keyword">return</span> code;

              min = Math.min(matches[<span class="integer">0</span>].length, min);
            }

            <span class="comment">// trim minimum common number of white space from the begining of every line</span>
            <span class="keyword">if</span> (min &gt; <span class="integer">0</span>) <span class="keyword">for</span> (i = <span class="integer">0</span>, l = lines.length; i &lt; l; i++) {
              <span class="keyword">if</span> (!isEmpty(lines[i])) lines[i] = lines[i].substr(min);
            }<span class="keyword">return</span> lines.join(<span class="string"><span class="delimiter">'</span><span class="content">\n</span><span class="delimiter">'</span></span>);
          }
        };

<span class="comment">/***/</span> },
<span class="comment">/* 16 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> spaces = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>;

        <span class="comment">// Create a string with 1000 spaces to copy spaces from...</span>
        <span class="comment">// It's assumed that there would be no indentation longer than that.</span>
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>; i &lt; <span class="integer">50</span>; i++) {
          spaces += <span class="string"><span class="delimiter">'</span><span class="content">                    </span><span class="delimiter">'</span></span>;
        } <span class="comment">// 20 spaces * 50</span>

        <span class="comment">// This function inserts specified amount of spaces in the string</span>
        <span class="comment">// where a tab is while removing that given tab.</span>
        <span class="keyword">function</span> <span class="function">insertSpaces</span>(line, pos, count) {
          <span class="keyword">return</span> line.substr(<span class="integer">0</span>, pos) + spaces.substr(<span class="integer">0</span>, count) + line.substr(pos + <span class="integer">1</span>, line.length) <span class="comment">// pos + 1 will get rid of the tab</span>
          ;
        }

        module.exports = {
          <span class="function">smart</span>: <span class="keyword">function</span> <span class="function">smart</span>(code, tabSize) {
            <span class="keyword">var</span> lines = code.split(<span class="regexp"><span class="delimiter">/</span><span class="char">\r</span><span class="content">?</span><span class="char">\n</span><span class="delimiter">/</span></span>),
                tab = <span class="string"><span class="delimiter">'</span><span class="content">\t</span><span class="delimiter">'</span></span>,
                line,
                pos,
                i,
                l;

            <span class="comment">// Go through all the lines and do the 'smart tabs' magic.</span>
            <span class="keyword">for</span> (i = <span class="integer">0</span>, l = lines.length; i &lt; l; i++) {
              line = lines[i];

              <span class="keyword">if</span> (line.indexOf(tab) === -<span class="integer">1</span>) <span class="keyword">continue</span>;

              pos = <span class="integer">0</span>;

              <span class="keyword">while</span> ((pos = line.indexOf(tab)) !== -<span class="integer">1</span>) {
                <span class="comment">// This is pretty much all there is to the 'smart tabs' logic.</span>
                <span class="comment">// Based on the position within the line and size of a tab,</span>
                <span class="comment">// calculate the amount of spaces we need to insert.</span>
                line = insertSpaces(line, pos, tabSize - pos % tabSize);
              }

              lines[i] = line;
            }

            <span class="keyword">return</span> lines.join(<span class="string"><span class="delimiter">'</span><span class="content">\n</span><span class="delimiter">'</span></span>);
          },

          <span class="function">regular</span>: <span class="keyword">function</span> <span class="function">regular</span>(code, tabSize) {
            <span class="keyword">return</span> code.replace(<span class="regexp"><span class="delimiter">/</span><span class="char">\t</span><span class="delimiter">/</span><span class="modifier">g</span></span>, spaces.substr(<span class="integer">0</span>, tabSize));
          }
        };

<span class="comment">/***/</span> },
<span class="comment">/* 17 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="comment">/**
         * Finds all &amp;lt;SCRIPT TYPE=&quot;text/syntaxhighlighter&quot; /&gt; elementss.
         * Finds both &quot;text/syntaxhighlighter&quot; and &quot;syntaxhighlighter&quot;
         * ...in order to make W3C validator happy with subtype and backwardscompatible without subtype
         * @return {Array} Returns array of all found SyntaxHighlighter tags.
         */</span>
        <span class="keyword">function</span> <span class="function">getSyntaxHighlighterScriptTags</span>() {
          <span class="keyword">var</span> tags = document.getElementsByTagName(<span class="string"><span class="delimiter">'</span><span class="content">script</span><span class="delimiter">'</span></span>),
              result = [];

          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>; i &lt; tags.length; i++) {
            <span class="keyword">if</span> (tags[i].type == <span class="string"><span class="delimiter">'</span><span class="content">text/syntaxhighlighter</span><span class="delimiter">'</span></span> || tags[i].type == <span class="string"><span class="delimiter">'</span><span class="content">syntaxhighlighter</span><span class="delimiter">'</span></span>) result.push(tags[i]);
          }<span class="keyword">return</span> result;
        };

        <span class="comment">/**
         * Checks if target DOM elements has specified CSS class.
         * @param {DOMElement} target Target DOM element to check.
         * @param {String} className Name of the CSS class to check for.
         * @return {Boolean} Returns true if class name is present, false otherwise.
         */</span>
        <span class="keyword">function</span> <span class="function">hasClass</span>(target, className) {
          <span class="keyword">return</span> target.className.indexOf(className) != -<span class="integer">1</span>;
        }

        <span class="comment">/**
         * Adds CSS class name to the target DOM element.
         * @param {DOMElement} target Target DOM element.
         * @param {String} className New CSS class to add.
         */</span>
        <span class="keyword">function</span> <span class="function">addClass</span>(target, className) {
          <span class="keyword">if</span> (!hasClass(target, className)) target.className += <span class="string"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span> + className;
        }

        <span class="comment">/**
         * Removes CSS class name from the target DOM element.
         * @param {DOMElement} target Target DOM element.
         * @param {String} className CSS class to remove.
         */</span>
        <span class="keyword">function</span> <span class="function">removeClass</span>(target, className) {
          target.className = target.className.replace(className, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>);
        }

        <span class="comment">/**
         * Adds event handler to the target object.
         * @param {Object} obj    Target object.
         * @param {String} type   Name of the event.
         * @param {Function} func Handling function.
         */</span>
        <span class="keyword">function</span> <span class="function">attachEvent</span>(obj, type, func, scope) {
          <span class="keyword">function</span> <span class="function">handler</span>(e) {
            e = e || window.event;

            <span class="keyword">if</span> (!e.target) {
              e.target = e.srcElement;
              e.<span class="function">preventDefault</span> = <span class="keyword">function</span> () {
                <span class="local-variable">this</span>.returnValue = <span class="predefined-constant">false</span>;
              };
            }

            func.call(scope || window, e);
          };

          <span class="keyword">if</span> (obj.attachEvent) {
            obj.attachEvent(<span class="string"><span class="delimiter">'</span><span class="content">on</span><span class="delimiter">'</span></span> + type, handler);
          } <span class="keyword">else</span> {
            obj.addEventListener(type, handler, <span class="predefined-constant">false</span>);
          }
        }

        <span class="comment">/**
         * Looks for a child or parent node which has specified classname.
         * Equivalent to jQuery's $(container).find(&quot;.className&quot;)
         * @param {Element} target Target element.
         * @param {String} search Class name or node name to look for.
         * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
         * @return {Element} Returns found child or parent element on null.
         */</span>
        <span class="keyword">function</span> <span class="function">findElement</span>(target, search, reverse <span class="comment">/* optional */</span>) {
          <span class="keyword">if</span> (target == <span class="predefined-constant">null</span>) <span class="keyword">return</span> <span class="predefined-constant">null</span>;

          <span class="keyword">var</span> nodes = reverse != <span class="predefined-constant">true</span> ? target.childNodes : [target.parentNode],
              propertyToFind = { <span class="key"><span class="delimiter">'</span><span class="content">#</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">id</span><span class="delimiter">'</span></span>, <span class="key"><span class="delimiter">'</span><span class="content">.</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="content">className</span><span class="delimiter">'</span></span> }[search.substr(<span class="integer">0</span>, <span class="integer">1</span>)] || <span class="string"><span class="delimiter">'</span><span class="content">nodeName</span><span class="delimiter">'</span></span>,
              expectedValue,
              found;

          expectedValue = propertyToFind != <span class="string"><span class="delimiter">'</span><span class="content">nodeName</span><span class="delimiter">'</span></span> ? search.substr(<span class="integer">1</span>) : search.toUpperCase();

          <span class="comment">// main return of the found node</span>
          <span class="keyword">if</span> ((target[propertyToFind] || <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>).indexOf(expectedValue) != -<span class="integer">1</span>) <span class="keyword">return</span> target;

          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>, l = nodes.length; nodes &amp;&amp; i &lt; l &amp;&amp; found == <span class="predefined-constant">null</span>; i++) {
            found = findElement(nodes[i], search, reverse);
          }<span class="keyword">return</span> found;
        }

        <span class="comment">/**
         * Looks for a parent node which has specified classname.
         * This is an alias to &lt;code&gt;findElement(container, className, true)&lt;/code&gt;.
         * @param {Element} target Target element.
         * @param {String} className Class name to look for.
         * @return {Element} Returns found parent element on null.
         */</span>
        <span class="keyword">function</span> <span class="function">findParentElement</span>(target, className) {
          <span class="keyword">return</span> findElement(target, className, <span class="predefined-constant">true</span>);
        }

        <span class="comment">/**
         * Opens up a centered popup window.
         * @param {String} url    URL to open in the window.
         * @param {String} name   Popup name.
         * @param {int} width   Popup width.
         * @param {int} height    Popup height.
         * @param {String} options  window.open() options.
         * @return {Window}     Returns window instance.
         */</span>
        <span class="keyword">function</span> <span class="function">popup</span>(url, name, width, height, options) {
          <span class="keyword">var</span> x = (screen.width - width) / <span class="integer">2</span>,
              y = (screen.height - height) / <span class="integer">2</span>;

          options += <span class="string"><span class="delimiter">'</span><span class="content">, left=</span><span class="delimiter">'</span></span> + x + <span class="string"><span class="delimiter">'</span><span class="content">, top=</span><span class="delimiter">'</span></span> + y + <span class="string"><span class="delimiter">'</span><span class="content">, width=</span><span class="delimiter">'</span></span> + width + <span class="string"><span class="delimiter">'</span><span class="content">, height=</span><span class="delimiter">'</span></span> + height;
          options = options.replace(<span class="regexp"><span class="delimiter">/</span><span class="content">^,</span><span class="delimiter">/</span></span>, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>);

          <span class="keyword">var</span> win = window.open(url, name, options);
          win.focus();
          <span class="keyword">return</span> win;
        }

        <span class="keyword">function</span> <span class="function">getElementsByTagName</span>(name) {
          <span class="keyword">return</span> document.getElementsByTagName(name);
        }

        <span class="comment">/**
         * Finds all elements on the page which could be processes by SyntaxHighlighter.
         */</span>
        <span class="keyword">function</span> <span class="function">findElementsToHighlight</span>(opts) {
          <span class="keyword">var</span> elements = getElementsByTagName(opts[<span class="string"><span class="delimiter">'</span><span class="content">tagName</span><span class="delimiter">'</span></span>]),
              scripts,
              i;

          <span class="comment">// support for &lt;SCRIPT TYPE=&quot;syntaxhighlighter&quot; /&gt; feature</span>
          <span class="keyword">if</span> (opts[<span class="string"><span class="delimiter">'</span><span class="content">useScriptTags</span><span class="delimiter">'</span></span>]) {
            scripts = getElementsByTagName(<span class="string"><span class="delimiter">'</span><span class="content">script</span><span class="delimiter">'</span></span>);

            <span class="keyword">for</span> (i = <span class="integer">0</span>; i &lt; scripts.length; i++) {
              <span class="keyword">if</span> (scripts[i].type.match(<span class="regexp"><span class="delimiter">/</span><span class="content">^(text</span><span class="content">\/</span><span class="content">)?syntaxhighlighter$</span><span class="delimiter">/</span></span>)) elements.push(scripts[i]);
            }
          }

          <span class="keyword">return</span> elements;
        }

        <span class="keyword">function</span> <span class="function">create</span>(name) {
          <span class="keyword">return</span> document.createElement(name);
        }

        <span class="comment">/**
         * Quick code mouse double click handler.
         */</span>
        <span class="keyword">function</span> <span class="function">quickCodeHandler</span>(e) {
          <span class="keyword">var</span> target = e.target,
              highlighterDiv = findParentElement(target, <span class="string"><span class="delimiter">'</span><span class="content">.syntaxhighlighter</span><span class="delimiter">'</span></span>),
              container = findParentElement(target, <span class="string"><span class="delimiter">'</span><span class="content">.container</span><span class="delimiter">'</span></span>),
              textarea = document.createElement(<span class="string"><span class="delimiter">'</span><span class="content">textarea</span><span class="delimiter">'</span></span>),
              highlighter;

          <span class="keyword">if</span> (!container || !highlighterDiv || findElement(container, <span class="string"><span class="delimiter">'</span><span class="content">textarea</span><span class="delimiter">'</span></span>)) <span class="keyword">return</span>;

          <span class="comment">//highlighter = highlighters.get(highlighterDiv.id);</span>

          <span class="comment">// add source class name</span>
          addClass(highlighterDiv, <span class="string"><span class="delimiter">'</span><span class="content">source</span><span class="delimiter">'</span></span>);

          <span class="comment">// Have to go over each line and grab it's text, can't just do it on the</span>
          <span class="comment">// container because Firefox loses all \n where as Webkit doesn't.</span>
          <span class="keyword">var</span> lines = container.childNodes,
              code = [];

          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>, l = lines.length; i &lt; l; i++) {
            code.push(lines[i].innerText || lines[i].textContent);
          } <span class="comment">// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit</span>
          code = code.join(<span class="string"><span class="delimiter">'</span><span class="content">\r</span><span class="delimiter">'</span></span>);

          <span class="comment">// For Webkit browsers, replace nbsp with a breaking space</span>
          code = code.replace(<span class="regexp"><span class="delimiter">/</span><span class="char">\u00a0</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>);

          <span class="comment">// inject &lt;textarea/&gt; tag</span>
          textarea.readOnly = <span class="predefined-constant">true</span>; <span class="comment">// https://github.com/syntaxhighlighter/syntaxhighlighter/pull/329</span>
          textarea.appendChild(document.createTextNode(code));
          container.appendChild(textarea);

          <span class="comment">// preselect all text</span>
          textarea.focus();
          textarea.select();

          <span class="comment">// set up handler for lost focus</span>
          attachEvent(textarea, <span class="string"><span class="delimiter">'</span><span class="content">blur</span><span class="delimiter">'</span></span>, <span class="keyword">function</span> (e) {
            textarea.parentNode.removeChild(textarea);
            removeClass(highlighterDiv, <span class="string"><span class="delimiter">'</span><span class="content">source</span><span class="delimiter">'</span></span>);
          });
        };

        module.exports = {
          <span class="key">quickCodeHandler</span>: quickCodeHandler,
          <span class="key">create</span>: create,
          <span class="key">popup</span>: popup,
          <span class="key">hasClass</span>: hasClass,
          <span class="key">addClass</span>: addClass,
          <span class="key">removeClass</span>: removeClass,
          <span class="key">attachEvent</span>: attachEvent,
          <span class="key">findElement</span>: findElement,
          <span class="key">findParentElement</span>: findParentElement,
          <span class="key">getSyntaxHighlighterScriptTags</span>: getSyntaxHighlighterScriptTags,
          <span class="key">findElementsToHighlight</span>: findElementsToHighlight
        };

<span class="comment">/***/</span> },
<span class="comment">/* 18 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        module.exports = {
          <span class="key">space</span>: <span class="string"><span class="delimiter">'</span><span class="content">&amp;nbsp;</span><span class="delimiter">'</span></span>,

          <span class="comment">/** Enables use of &lt;SCRIPT type=&quot;syntaxhighlighter&quot; /&gt; tags. */</span>
          <span class="key">useScriptTags</span>: <span class="predefined-constant">true</span>,

          <span class="comment">/** Blogger mode flag. */</span>
          <span class="key">bloggerMode</span>: <span class="predefined-constant">false</span>,

          <span class="key">stripBrs</span>: <span class="predefined-constant">false</span>,

          <span class="comment">/** Name of the tag that SyntaxHighlighter will automatically look for. */</span>
          <span class="key">tagName</span>: <span class="string"><span class="delimiter">'</span><span class="content">pre</span><span class="delimiter">'</span></span>
        };

<span class="comment">/***/</span> },
<span class="comment">/* 19 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        module.exports = {
          <span class="comment">/** Additional CSS class names to be added to highlighter elements. */</span>
          <span class="key"><span class="delimiter">'</span><span class="content">class-name</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>,

          <span class="comment">/** First line number. */</span>
          <span class="key"><span class="delimiter">'</span><span class="content">first-line</span><span class="delimiter">'</span></span>: <span class="integer">1</span>,

          <span class="comment">/**
           * Pads line numbers. Possible values are:
           *
           *   false - don't pad line numbers.
           *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
           *   [int] - length up to which pad line numbers.
           */</span>
          <span class="key"><span class="delimiter">'</span><span class="content">pad-line-numbers</span><span class="delimiter">'</span></span>: <span class="predefined-constant">false</span>,

          <span class="comment">/** Lines to highlight. */</span>
          <span class="key"><span class="delimiter">'</span><span class="content">highlight</span><span class="delimiter">'</span></span>: <span class="predefined-constant">null</span>,

          <span class="comment">/** Title to be displayed above the code block. */</span>
          <span class="key"><span class="delimiter">'</span><span class="content">title</span><span class="delimiter">'</span></span>: <span class="predefined-constant">null</span>,

          <span class="comment">/** Enables or disables smart tabs. */</span>
          <span class="key"><span class="delimiter">'</span><span class="content">smart-tabs</span><span class="delimiter">'</span></span>: <span class="predefined-constant">true</span>,

          <span class="comment">/** Gets or sets tab size. */</span>
          <span class="key"><span class="delimiter">'</span><span class="content">tab-size</span><span class="delimiter">'</span></span>: <span class="integer">4</span>,

          <span class="comment">/** Enables or disables gutter. */</span>
          <span class="key"><span class="delimiter">'</span><span class="content">gutter</span><span class="delimiter">'</span></span>: <span class="predefined-constant">true</span>,

          <span class="comment">/** Enables quick code copy and paste from double click. */</span>
          <span class="key"><span class="delimiter">'</span><span class="content">quick-code</span><span class="delimiter">'</span></span>: <span class="predefined-constant">true</span>,

          <span class="comment">/** Forces code view to be collapsed. */</span>
          <span class="key"><span class="delimiter">'</span><span class="content">collapse</span><span class="delimiter">'</span></span>: <span class="predefined-constant">false</span>,

          <span class="comment">/** Enables or disables automatic links. */</span>
          <span class="key"><span class="delimiter">'</span><span class="content">auto-links</span><span class="delimiter">'</span></span>: <span class="predefined-constant">true</span>,

          <span class="key"><span class="delimiter">'</span><span class="content">unindent</span><span class="delimiter">'</span></span>: <span class="predefined-constant">true</span>,

          <span class="key"><span class="delimiter">'</span><span class="content">html-script</span><span class="delimiter">'</span></span>: <span class="predefined-constant">false</span>
        };

<span class="comment">/***/</span> },
<span class="comment">/* 20 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="comment">/* WEBPACK VAR INJECTION */</span>(<span class="keyword">function</span>(process) {<span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> applyRegexList = __webpack_require__(<span class="integer">5</span>).applyRegexList;

        <span class="keyword">function</span> <span class="function">HtmlScript</span>(BrushXML, brushClass) {
          <span class="keyword">var</span> scriptBrush,
              xmlBrush = <span class="keyword">new</span> BrushXML();

          <span class="keyword">if</span> (brushClass == <span class="predefined-constant">null</span>) <span class="keyword">return</span>;

          scriptBrush = <span class="keyword">new</span> brushClass();

          <span class="keyword">if</span> (scriptBrush.htmlScript == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">Brush wasn</span><span class="char">\'</span><span class="content">t configured for html-script option: </span><span class="delimiter">'</span></span> + brushClass.brushName);

          xmlBrush.regexList.push({ <span class="key">regex</span>: scriptBrush.htmlScript.code, <span class="key">func</span>: process });

          <span class="local-variable">this</span>.regexList = xmlBrush.regexList;

          <span class="keyword">function</span> <span class="function">offsetMatches</span>(matches, offset) {
            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="integer">0</span>, l = matches.length; j &lt; l; j++) {
              matches[j].index += offset;
            }
          }

          <span class="keyword">function</span> <span class="function">process</span>(match, info) {
            <span class="keyword">var</span> code = match.code,
                results = [],
                regexList = scriptBrush.regexList,
                offset = match.index + match.left.length,
                htmlScript = scriptBrush.htmlScript,
                matches;

            <span class="keyword">function</span> <span class="function">add</span>(matches) {
              results = results.concat(matches);
            }

            matches = applyRegexList(code, regexList);
            offsetMatches(matches, offset);
            add(matches);

            <span class="comment">// add left script bracket</span>
            <span class="keyword">if</span> (htmlScript.left != <span class="predefined-constant">null</span> &amp;&amp; match.left != <span class="predefined-constant">null</span>) {
              matches = applyRegexList(match.left, [htmlScript.left]);
              offsetMatches(matches, match.index);
              add(matches);
            }

            <span class="comment">// add right script bracket</span>
            <span class="keyword">if</span> (htmlScript.right != <span class="predefined-constant">null</span> &amp;&amp; match.right != <span class="predefined-constant">null</span>) {
              matches = applyRegexList(match.right, [htmlScript.right]);
              offsetMatches(matches, match.index + match[<span class="integer">0</span>].lastIndexOf(match.right));
              add(matches);
            }

            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="integer">0</span>, l = results.length; j &lt; l; j++) {
              results[j].brushName = brushClass.brushName;
            }<span class="keyword">return</span> results;
          }
        };

        module.exports = HtmlScript;
        <span class="comment">/* WEBPACK VAR INJECTION */</span>}.call(exports, __webpack_require__(<span class="integer">21</span>)))

<span class="comment">/***/</span> },
<span class="comment">/* 21 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="comment">// shim for using process in browser</span>

        <span class="keyword">var</span> process = module.exports = {};

        <span class="comment">// cached from whatever global is present so that test runners that stub it</span>
        <span class="comment">// don't break things.  But we need to wrap it in a try catch in case it is</span>
        <span class="comment">// wrapped in strict mode code which doesn't define any globals.  It's inside a</span>
        <span class="comment">// function because try/catches deoptimize in certain engines.</span>

        <span class="keyword">var</span> cachedSetTimeout;
        <span class="keyword">var</span> cachedClearTimeout;

        (<span class="keyword">function</span> () {
            <span class="keyword">try</span> {
                cachedSetTimeout = setTimeout;
            } <span class="keyword">catch</span> (e) {
                <span class="function">cachedSetTimeout</span> = <span class="keyword">function</span> <span class="function">cachedSetTimeout</span>() {
                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">setTimeout is not defined</span><span class="delimiter">'</span></span>);
                };
            }
            <span class="keyword">try</span> {
                cachedClearTimeout = clearTimeout;
            } <span class="keyword">catch</span> (e) {
                <span class="function">cachedClearTimeout</span> = <span class="keyword">function</span> <span class="function">cachedClearTimeout</span>() {
                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">clearTimeout is not defined</span><span class="delimiter">'</span></span>);
                };
            }
        })();
        <span class="keyword">var</span> queue = [];
        <span class="keyword">var</span> draining = <span class="predefined-constant">false</span>;
        <span class="keyword">var</span> currentQueue;
        <span class="keyword">var</span> queueIndex = -<span class="integer">1</span>;

        <span class="keyword">function</span> <span class="function">cleanUpNextTick</span>() {
            <span class="keyword">if</span> (!draining || !currentQueue) {
                <span class="keyword">return</span>;
            }
            draining = <span class="predefined-constant">false</span>;
            <span class="keyword">if</span> (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } <span class="keyword">else</span> {
                queueIndex = -<span class="integer">1</span>;
            }
            <span class="keyword">if</span> (queue.length) {
                drainQueue();
            }
        }

        <span class="keyword">function</span> <span class="function">drainQueue</span>() {
            <span class="keyword">if</span> (draining) {
                <span class="keyword">return</span>;
            }
            <span class="keyword">var</span> timeout = cachedSetTimeout(cleanUpNextTick);
            draining = <span class="predefined-constant">true</span>;

            <span class="keyword">var</span> len = queue.length;
            <span class="keyword">while</span> (len) {
                currentQueue = queue;
                queue = [];
                <span class="keyword">while</span> (++queueIndex &lt; len) {
                    <span class="keyword">if</span> (currentQueue) {
                        currentQueue[queueIndex].run();
                    }
                }
                queueIndex = -<span class="integer">1</span>;
                len = queue.length;
            }
            currentQueue = <span class="predefined-constant">null</span>;
            draining = <span class="predefined-constant">false</span>;
            cachedClearTimeout(timeout);
        }

        process.<span class="function">nextTick</span> = <span class="keyword">function</span> (fun) {
            <span class="keyword">var</span> args = <span class="keyword">new</span> Array(<span class="local-variable">arguments</span>.length - <span class="integer">1</span>);
            <span class="keyword">if</span> (<span class="local-variable">arguments</span>.length &gt; <span class="integer">1</span>) {
                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">1</span>; i &lt; <span class="local-variable">arguments</span>.length; i++) {
                    args[i - <span class="integer">1</span>] = <span class="local-variable">arguments</span>[i];
                }
            }
            queue.push(<span class="keyword">new</span> Item(fun, args));
            <span class="keyword">if</span> (queue.length === <span class="integer">1</span> &amp;&amp; !draining) {
                cachedSetTimeout(drainQueue, <span class="integer">0</span>);
            }
        };

        <span class="comment">// v8 likes predictible objects</span>
        <span class="keyword">function</span> <span class="function">Item</span>(fun, array) {
            <span class="local-variable">this</span>.fun = fun;
            <span class="local-variable">this</span>.array = array;
        }
        Item.prototype.<span class="function">run</span> = <span class="keyword">function</span> () {
            <span class="local-variable">this</span>.fun.apply(<span class="predefined-constant">null</span>, <span class="local-variable">this</span>.array);
        };
        process.title = <span class="string"><span class="delimiter">'</span><span class="content">browser</span><span class="delimiter">'</span></span>;
        process.browser = <span class="predefined-constant">true</span>;
        process.env = {};
        process.argv = [];
        process.version = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>; <span class="comment">// empty string to avoid regexp issues</span>
        process.versions = {};

        <span class="keyword">function</span> <span class="function">noop</span>() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;

        process.<span class="function">binding</span> = <span class="keyword">function</span> (name) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">process.binding is not supported</span><span class="delimiter">'</span></span>);
        };

        process.<span class="function">cwd</span> = <span class="keyword">function</span> () {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="content">/</span><span class="delimiter">'</span></span>;
        };
        process.<span class="function">chdir</span> = <span class="keyword">function</span> (dir) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">process.chdir is not supported</span><span class="delimiter">'</span></span>);
        };
        process.<span class="function">umask</span> = <span class="keyword">function</span> () {
            <span class="keyword">return</span> <span class="integer">0</span>;
        };

<span class="comment">/***/</span> },
<span class="comment">/* 22 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> <span class="function">_createClass</span> = <span class="keyword">function</span> () { <span class="keyword">function</span> <span class="function">defineProperties</span>(target, props) { <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>; i &lt; props.length; i++) { <span class="keyword">var</span> descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || <span class="predefined-constant">false</span>; descriptor.configurable = <span class="predefined-constant">true</span>; <span class="keyword">if</span> (<span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="predefined-constant">true</span>; Object.defineProperty(target, descriptor.key, descriptor); } } <span class="keyword">return</span> <span class="keyword">function</span> (Constructor, protoProps, staticProps) { <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps); <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps); <span class="keyword">return</span> Constructor; }; }();

        <span class="keyword">var</span> _syntaxhighlighterHtmlRenderer = __webpack_require__(<span class="integer">9</span>);

        <span class="keyword">var</span> _syntaxhighlighterHtmlRenderer2 = _interopRequireDefault(_syntaxhighlighterHtmlRenderer);

        <span class="keyword">var</span> _syntaxhighlighterRegex = __webpack_require__(<span class="integer">3</span>);

        <span class="keyword">var</span> _syntaxhighlighterMatch = __webpack_require__(<span class="integer">5</span>);

        <span class="keyword">function</span> <span class="function">_interopRequireDefault</span>(obj) { <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : { <span class="keyword">default</span>: obj }; }

        <span class="keyword">function</span> <span class="function">_classCallCheck</span>(instance, Constructor) { <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) { <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string"><span class="delimiter">&quot;</span><span class="content">Cannot call a class as a function</span><span class="delimiter">&quot;</span></span>); } }

        module.<span class="function">exports</span> = <span class="keyword">function</span> () {
          <span class="keyword">function</span> <span class="function">BrushBase</span>() {
            _classCallCheck(<span class="local-variable">this</span>, BrushBase);
          }

          _createClass(BrushBase, [{
            <span class="key">key</span>: <span class="string"><span class="delimiter">'</span><span class="content">getKeywords</span><span class="delimiter">'</span></span>,

            <span class="comment">/**
             * Converts space separated list of keywords into a regular expression string.
             * @param {String} str Space separated keywords.
             * @return {String} Returns regular expression string.
             */</span>
            <span class="function">value</span>: <span class="keyword">function</span> <span class="function">getKeywords</span>(str) {
              <span class="keyword">var</span> results = str.replace(<span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="char">\s</span><span class="content">+|</span><span class="char">\s</span><span class="content">+$</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>).replace(<span class="regexp"><span class="delimiter">/</span><span class="char">\s</span><span class="content">+</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">|</span><span class="delimiter">'</span></span>);

              <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">b(?:</span><span class="delimiter">'</span></span> + results + <span class="string"><span class="delimiter">'</span><span class="content">)</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span>;
            }

            <span class="comment">/**
             * Makes a brush compatible with the `html-script` functionality.
             * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
             */</span>

          }, {
            <span class="key">key</span>: <span class="string"><span class="delimiter">'</span><span class="content">forHtmlScript</span><span class="delimiter">'</span></span>,
            <span class="function">value</span>: <span class="keyword">function</span> <span class="function">forHtmlScript</span>(regexGroup) {
              <span class="keyword">var</span> regex = { <span class="key"><span class="delimiter">'</span><span class="content">end</span><span class="delimiter">'</span></span>: regexGroup.right.source };

              <span class="keyword">if</span> (regexGroup.eof) {
                regex.end = <span class="string"><span class="delimiter">'</span><span class="content">(?:(?:</span><span class="delimiter">'</span></span> + regex.end + <span class="string"><span class="delimiter">'</span><span class="content">)|$)</span><span class="delimiter">'</span></span>;
              }

              <span class="local-variable">this</span>.htmlScript = {
                <span class="key">left</span>: { <span class="key">regex</span>: regexGroup.left, <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">script</span><span class="delimiter">'</span></span> },
                <span class="key">right</span>: { <span class="key">regex</span>: regexGroup.right, <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">script</span><span class="delimiter">'</span></span> },
                <span class="key">code</span>: (<span class="integer">0</span>, _syntaxhighlighterRegex.XRegExp)(<span class="string"><span class="delimiter">&quot;</span><span class="content">(?&lt;left&gt;</span><span class="delimiter">&quot;</span></span> + regexGroup.left.source + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span> + <span class="string"><span class="delimiter">&quot;</span><span class="content">(?&lt;code&gt;.*?)</span><span class="delimiter">&quot;</span></span> + <span class="string"><span class="delimiter">&quot;</span><span class="content">(?&lt;right&gt;</span><span class="delimiter">&quot;</span></span> + regex.end + <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">sgi</span><span class="delimiter">&quot;</span></span>)
              };
            }
          }, {
            <span class="key">key</span>: <span class="string"><span class="delimiter">'</span><span class="content">getHtml</span><span class="delimiter">'</span></span>,
            <span class="function">value</span>: <span class="keyword">function</span> <span class="function">getHtml</span>(code) {
              <span class="keyword">var</span> params = <span class="local-variable">arguments</span>.length &lt;= <span class="integer">1</span> || <span class="local-variable">arguments</span>[<span class="integer">1</span>] === <span class="predefined-constant">undefined</span> ? {} : <span class="local-variable">arguments</span>[<span class="integer">1</span>];

              <span class="keyword">var</span> matches = (<span class="integer">0</span>, _syntaxhighlighterMatch.applyRegexList)(code, <span class="local-variable">this</span>.regexList);
              <span class="keyword">var</span> renderer = <span class="keyword">new</span> _syntaxhighlighterHtmlRenderer2.<span class="keyword">default</span>(code, matches, params);
              <span class="keyword">return</span> renderer.getHtml();
            }
          }]);

          <span class="keyword">return</span> BrushBase;
        }();

<span class="comment">/***/</span> },
<span class="comment">/* 23 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="comment">// AppleScript brush by David Chambers</span>
          <span class="comment">// http://davidchambersdesign.com/</span>
          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">after before beginning continue copy each end every from return get global in local named of set some that the then times to where whose with without</span><span class="delimiter">'</span></span>;
          <span class="keyword">var</span> ordinals = <span class="string"><span class="delimiter">'</span><span class="content">first second third fourth fifth sixth seventh eighth ninth tenth last front back middle</span><span class="delimiter">'</span></span>;
          <span class="keyword">var</span> specials = <span class="string"><span class="delimiter">'</span><span class="content">activate add alias ask attachment boolean class constant delete duplicate empty exists id integer list make message modal modified new no pi properties quit real record remove rest result reveal reverse run running save string word yes</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(--|#).*$</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\(</span><span class="content">\*</span><span class="content">(?:[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?</span><span class="content">\(</span><span class="content">\*</span><span class="content">[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?</span><span class="content">\*</span><span class="content">\)</span><span class="content">)*[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?</span><span class="content">\*</span><span class="content">\)</span><span class="delimiter">/</span><span class="modifier">gm</span></span>, <span class="comment">// support nested comments</span>
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">&quot;[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?&quot;</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(?:,|:|¬|'s</span><span class="char">\b</span><span class="content">|</span><span class="content">\(</span><span class="content">|</span><span class="content">\)</span><span class="content">|</span><span class="content">\{</span><span class="content">|</span><span class="content">\}</span><span class="content">|«|</span><span class="char">\b</span><span class="char">\w</span><span class="content">*»)</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="comment">// operators</span>
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(-)?(</span><span class="char">\d</span><span class="content">)+(</span><span class="content">\.</span><span class="content">(</span><span class="char">\d</span><span class="content">)?)?(E</span><span class="content">\+</span><span class="content">(</span><span class="char">\d</span><span class="content">)+)?</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="comment">// numbers</span>
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(?:&amp;(amp;|gt;|lt;)?|=|&gt;|&lt;|≥|&gt;=|≤|&lt;=|</span><span class="content">\*</span><span class="content">|</span><span class="content">\+</span><span class="content">|-|</span><span class="content">\/</span><span class="content">|÷|</span><span class="content">\^</span><span class="content">)</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color2</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">(?:and|as|div|mod|not|or|return(?!</span><span class="char">\s</span><span class="content">&amp;)(ing)?|equals|(is(n't| not)? )?equal( to)?|does(n't| not) equal|(is(n't| not)? )?(greater|less) than( or equal( to)?)?|(comes|does(n't| not) come) (after|before)|is(n't| not)?( in)? (back|front) of|is(n't| not)? behind|is(n't| not)?( (in|contained by))?|does(n't| not) contain|contain(s)?|(start|begin|end)(s)? with|((but|end) )?(consider|ignor)ing|prop(erty)?|(a )?ref(erence)?( to)?|repeat (until|while|with)|((end|exit) )?repeat|((else|end) )?if|else|(end )?(script|tell|try)|(on )?error|(put )?into|(of )?(it|me)|its|my|with (timeout( of)?|transaction)|end (timeout|transaction))</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="char">\d</span><span class="content">+(st|nd|rd|th)</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="comment">// ordinals</span>
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">(?:about|above|against|around|at|below|beneath|beside|between|by|(apart|aside) from|(instead|out) of|into|on(to)?|over|since|thr(ough|u)|under)</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color3</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">(?:adding folder items to|after receiving|clipboard info|set the clipboard to|(the )?clipboard|entire contents|document( (edited|file|nib name))?|file( (name|type))?|(info )?for|giving up after|(name )?extension|return(ed)?|second(?! item)(s)?|list (disks|folder)|(Unicode )?text|(disk )?item(s)?|((current|list) )?view|((container|key) )?window|case|diacriticals|hyphens|numeric strings|punctuation|white space|folder creation|application(s( folder)?| (processes|scripts position|support))?|((desktop )?(pictures )?|(documents|downloads|favorites|home|keychain|library|movies|music|public|scripts|sites|system|users|utilities|workflows) )folder|desktop|Folder Action scripts|font(s| panel)?|help|internet plugins|modem scripts|(system )?preferences|printer descriptions|scripting (additions|components)|shared (documents|libraries)|startup (disk|items)|temporary items|trash|on server|in AppleTalk zone|((as|long|short) )?user name|user (ID|locale)|(with )?password|in (bundle( with identifier)?|directory)|(close|open for) access|read|write( permission)?|(g|s)et eof|starting at|hidden( answer)?|open(ed| (location|untitled))?|error (handling|reporting)|administrator privileges|altering line endings|get volume settings|(alert|boot|input|mount|output|set) volume|output muted|(fax|random )?number|round(ing)?|up|down|toward zero|to nearest|as taught in school|system (attribute|info)|((AppleScript( Studio)?|system) )?version|(home )?directory|(IPv4|primary Ethernet) address|CPU (type|speed)|physical memory|time (stamp|to GMT)|replacing|ASCII (character|number)|localized string|from table|offset|summarize|beep|delay|say|(empty|multiple) selections allowed|(of|preferred) type|invisibles|showing( package contents)?|editable URL|(File|FTP|News|Media|Web) [Ss]ervers|Telnet hosts|Directory services|Remote applications|waiting until completion|saving( (in|to))?|path (for|to( (((current|frontmost) )?application|resource))?)|(background|RGB) color|(OK|cancel) button name|cancel button|button(s)?|cubic ((centi)?met(re|er)s|yards|feet|inches)|square ((kilo)?met(re|er)s|miles|yards|feet)|(centi|kilo)?met(re|er)s|miles|yards|feet|inches|lit(re|er)s|gallons|quarts|(kilo)?grams|ounces|pounds|degrees (Celsius|Fahrenheit|Kelvin)|print( (dialog|settings))?|clos(e(able)?|ing)|(de)?miniaturized|miniaturizable|zoom(ed|able)|attribute run|action (method|property|title)|phone|email|((start|end)ing|home) page|((birth|creation|current|custom|modification) )?date|((((phonetic )?(first|last|middle))|computer|host|maiden|related) |nick)?name|aim|icq|jabber|msn|yahoo|address(es)?|save addressbook|should enable action|city|country( code)?|formatte(r|d address)|(palette )?label|state|street|zip|AIM [Hh]andle(s)?|my card|select(ion| all)?|unsaved|(alpha )?value|entr(y|ies)|(ICQ|Jabber|MSN) handle|person|people|company|department|icon image|job title|note|organization|suffix|vcard|url|copies|collating|pages (across|down)|request print time|target( printer)?|((GUI Scripting|Script menu) )?enabled|show Computer scripts|(de)?activated|awake from nib|became (key|main)|call method|of (class|object)|center|clicked toolbar item|closed|for document|exposed|(can )?hide|idle|keyboard (down|up)|event( (number|type))?|launch(ed)?|load (image|movie|nib|sound)|owner|log|mouse (down|dragged|entered|exited|moved|up)|move|column|localization|resource|script|register|drag (info|types)|resigned (active|key|main)|resiz(e(d)?|able)|right mouse (down|dragged|up)|scroll wheel|(at )?index|should (close|open( untitled)?|quit( after last window closed)?|zoom)|((proposed|screen) )?bounds|show(n)?|behind|in front of|size (mode|to fit)|update(d| toolbar item)?|was (hidden|miniaturized)|will (become active|close|finish launching|hide|miniaturize|move|open|quit|(resign )?active|((maximum|minimum|proposed) )?size|show|zoom)|bundle|data source|movie|pasteboard|sound|tool(bar| tip)|(color|open|save) panel|coordinate system|frontmost|main( (bundle|menu|window))?|((services|(excluded from )?windows) )?menu|((executable|frameworks|resource|scripts|shared (frameworks|support)) )?path|(selected item )?identifier|data|content(s| view)?|character(s)?|click count|(command|control|option|shift) key down|context|delta (x|y|z)|key( code)?|location|pressure|unmodified characters|types|(first )?responder|playing|(allowed|selectable) identifiers|allows customization|(auto saves )?configuration|visible|image( name)?|menu form representation|tag|user(-| )defaults|associated file name|(auto|needs) display|current field editor|floating|has (resize indicator|shadow)|hides when deactivated|level|minimized (image|title)|opaque|position|release when closed|sheet|title(d)?)</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color4</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">(?:tracks|paragraph|text item(s)?)</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">classes</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">(?:AppleScript|album|video kind|grouping|length|text item delimiters|quoted form|POSIX path(?= of))</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">properties</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">(?:run|exists|count)</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">commandNames</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">(?:POSIX (file|path))</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">additionClasses</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">(?:message|with (data|icon( (caution|note|stop))?|parameter(s)?|prompt|properties|seed|title)|regexp|string result|using( delimiters)?|default (answer|button|color|country code|entr(y|ies)|identifiers|items|name|location|script editor))</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">additionParameterNames</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">(?:display(ing| (alert|dialog|mode))?|choose( ((remote )?application|color|folder|from list|URL))?|(do( shell)?|load|run|store) script|re_compile|find text)</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">additionCommandNames</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">(?:xxx)</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">parameterNames</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">(?:true|false|none)</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">enumeratedValues</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(specials), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color3</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(ordinals), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }];
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">applescript</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 24 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="comment">// Created by Peter Atoria @ http://iAtoria.com</span>

          <span class="keyword">var</span> inits = <span class="string"><span class="delimiter">'</span><span class="content">class interface function package</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">-Infinity ...rest Array as AS3 Boolean break case catch const continue Date decodeURI </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">decodeURIComponent default delete do dynamic each else encodeURI encodeURIComponent escape </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">extends false final finally flash_proxy for get if implements import in include Infinity </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">instanceof int internal is isFinite isNaN isXMLName label namespace NaN native new null </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Null Number Object object_proxy override parseFloat parseInt private protected public </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">return set static String super switch this throw true try typeof uint undefined unescape </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">use void while with</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: regexLib.singleLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.multiLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">([</span><span class="char">\d</span><span class="content">]+(</span><span class="content">\.</span><span class="content">[</span><span class="char">\d</span><span class="content">]+)?|0x[a-f0-9]+)</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">gi</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(inits), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color3</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">var</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">variable</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">trace</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }];

          <span class="local-variable">this</span>.forHtmlScript(regexLib.scriptScriptTags);
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">actionscript3</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">as3</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 25 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;
        <span class="keyword">var</span> XRegExp = __webpack_require__(<span class="integer">3</span>).XRegExp;
        <span class="keyword">var</span> Match = __webpack_require__(<span class="integer">5</span>).Match;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="keyword">function</span> <span class="function">hereDocProcess</span>(match, regexInfo) {
            <span class="keyword">var</span> result = [];

            <span class="keyword">if</span> (match.here_doc != <span class="predefined-constant">null</span>) result.push(<span class="keyword">new</span> Match(match.here_doc, match.index + match[<span class="integer">0</span>].indexOf(match.here_doc), <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>));

            <span class="keyword">if</span> (match.full_tag != <span class="predefined-constant">null</span>) result.push(<span class="keyword">new</span> Match(match.full_tag, match.index, <span class="string"><span class="delimiter">'</span><span class="content">preprocessor</span><span class="delimiter">'</span></span>));

            <span class="keyword">if</span> (match.end_tag != <span class="predefined-constant">null</span>) result.push(<span class="keyword">new</span> Match(match.end_tag, match.index + match[<span class="integer">0</span>].lastIndexOf(match.end_tag), <span class="string"><span class="delimiter">'</span><span class="content">preprocessor</span><span class="delimiter">'</span></span>));

            <span class="keyword">return</span> result;
          }

          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">if fi then elif else for do done until while break continue case esac function return in eq ne ge le</span><span class="delimiter">'</span></span>;
          <span class="keyword">var</span> commands = <span class="string"><span class="delimiter">'</span><span class="content">alias apropos awk basename base64 bash bc bg builtin bunzip2 bzcat bzip2 bzip2recover cal cat cd cfdisk chgrp chmod chown chroot</span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">cksum clear cmp comm command cp cron crontab crypt csplit cut date dc dd ddrescue declare df </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">diff diff3 dig dir dircolors dirname dirs du echo egrep eject enable env ethtool eval </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">exec exit expand export expr false fdformat fdisk fg fgrep file find fmt fold format </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">free fsck ftp gawk gcc gdb getconf getopts grep groups gunzip gzcat gzip hash head history hostname id ifconfig </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">import install join kill less let ln local locate logname logout look lpc lpr lprint </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">lprintd lprintq lprm ls lsof make man mkdir mkfifo mkisofs mknod more mount mtools </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">mv nasm nc ndisasm netstat nice nl nohup nslookup objdump od open op passwd paste pathchk ping popd pr printcap </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">printenv printf ps pushd pwd quota quotacheck quotactl ram rcp read readonly renice </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">remsync rm rmdir rsync screen scp sdiff sed select seq set sftp shift shopt shutdown </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">sleep sort source split ssh strace strings su sudo sum symlink sync tail tar tee test time </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">times touch top traceroute trap tr true tsort tty type ulimit umask umount unalias </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">uname unexpand uniq units unset unshar useradd usermod users uuencode uudecode v vdir </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">vi watch wc whereis which who whoami Wget xargs xxd yes chsh zcat</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">^#!.*$</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">preprocessor bold</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\/</span><span class="content">[</span><span class="char">\w</span><span class="content">-</span><span class="content">\/</span><span class="content">]+</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">plain</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleLinePerlComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(commands), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">functions</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> XRegExp(<span class="string"><span class="delimiter">&quot;</span><span class="content">(?&lt;full_tag&gt;(&amp;lt;|&lt;){2}(?&lt;tag&gt;</span><span class="char">\\</span><span class="content">w+)) .*$(?&lt;here_doc&gt;[</span><span class="char">\\</span><span class="content">s</span><span class="char">\\</span><span class="content">S]*)(?&lt;end_tag&gt;^</span><span class="char">\\</span><span class="content">k&lt;tag&gt;$)</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">func</span>: hereDocProcess
          }];
        }

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">bash</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">shell</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">sh</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 26 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="comment">// Contributed by Jen</span>
          <span class="comment">// http://www.jensbits.com/2009/05/14/coldfusion-brush-for-syntaxhighlighter-plus</span>

          <span class="keyword">var</span> funcs = <span class="string"><span class="delimiter">'</span><span class="content">Abs ACos AddSOAPRequestHeader AddSOAPResponseHeader AjaxLink AjaxOnLoad ArrayAppend ArrayAvg ArrayClear ArrayDeleteAt </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">ArrayInsertAt ArrayIsDefined ArrayIsEmpty ArrayLen ArrayMax ArrayMin ArraySet ArraySort ArraySum ArraySwap ArrayToList </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Asc ASin Atn BinaryDecode BinaryEncode BitAnd BitMaskClear BitMaskRead BitMaskSet BitNot BitOr BitSHLN BitSHRN BitXor </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Ceiling CharsetDecode CharsetEncode Chr CJustify Compare CompareNoCase Cos CreateDate CreateDateTime CreateObject </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">CreateODBCDate CreateODBCDateTime CreateODBCTime CreateTime CreateTimeSpan CreateUUID DateAdd DateCompare DateConvert </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">DateDiff DateFormat DatePart Day DayOfWeek DayOfWeekAsString DayOfYear DaysInMonth DaysInYear DE DecimalFormat DecrementValue </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Decrypt DecryptBinary DeleteClientVariable DeserializeJSON DirectoryExists DollarFormat DotNetToCFType Duplicate Encrypt </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">EncryptBinary Evaluate Exp ExpandPath FileClose FileCopy FileDelete FileExists FileIsEOF FileMove FileOpen FileRead </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">FileReadBinary FileReadLine FileSetAccessMode FileSetAttribute FileSetLastModified FileWrite Find FindNoCase FindOneOf </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">FirstDayOfMonth Fix FormatBaseN GenerateSecretKey GetAuthUser GetBaseTagData GetBaseTagList GetBaseTemplatePath </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">GetClientVariablesList GetComponentMetaData GetContextRoot GetCurrentTemplatePath GetDirectoryFromPath GetEncoding </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">GetException GetFileFromPath GetFileInfo GetFunctionList GetGatewayHelper GetHttpRequestData GetHttpTimeString </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">GetK2ServerDocCount GetK2ServerDocCountLimit GetLocale GetLocaleDisplayName GetLocalHostIP GetMetaData GetMetricData </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">GetPageContext GetPrinterInfo GetProfileSections GetProfileString GetReadableImageFormats GetSOAPRequest GetSOAPRequestHeader </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">GetSOAPResponse GetSOAPResponseHeader GetTempDirectory GetTempFile GetTemplatePath GetTickCount GetTimeZoneInfo GetToken </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">GetUserRoles GetWriteableImageFormats Hash Hour HTMLCodeFormat HTMLEditFormat IIf ImageAddBorder ImageBlur ImageClearRect </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">ImageCopy ImageCrop ImageDrawArc ImageDrawBeveledRect ImageDrawCubicCurve ImageDrawLine ImageDrawLines ImageDrawOval </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">ImageDrawPoint ImageDrawQuadraticCurve ImageDrawRect ImageDrawRoundRect ImageDrawText ImageFlip ImageGetBlob ImageGetBufferedImage </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">ImageGetEXIFTag ImageGetHeight ImageGetIPTCTag ImageGetWidth ImageGrayscale ImageInfo ImageNegative ImageNew ImageOverlay ImagePaste </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">ImageRead ImageReadBase64 ImageResize ImageRotate ImageRotateDrawingAxis ImageScaleToFit ImageSetAntialiasing ImageSetBackgroundColor </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">ImageSetDrawingColor ImageSetDrawingStroke ImageSetDrawingTransparency ImageSharpen ImageShear ImageShearDrawingAxis ImageTranslate </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">ImageTranslateDrawingAxis ImageWrite ImageWriteBase64 ImageXORDrawingMode IncrementValue InputBaseN Insert Int IsArray IsBinary </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">IsBoolean IsCustomFunction IsDate IsDDX IsDebugMode IsDefined IsImage IsImageFile IsInstanceOf IsJSON IsLeapYear IsLocalHost </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">IsNumeric IsNumericDate IsObject IsPDFFile IsPDFObject IsQuery IsSimpleValue IsSOAPRequest IsStruct IsUserInAnyRole IsUserInRole </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">IsUserLoggedIn IsValid IsWDDX IsXML IsXmlAttribute IsXmlDoc IsXmlElem IsXmlNode IsXmlRoot JavaCast JSStringFormat LCase Left Len </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">ListAppend ListChangeDelims ListContains ListContainsNoCase ListDeleteAt ListFind ListFindNoCase ListFirst ListGetAt ListInsertAt </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">ListLast ListLen ListPrepend ListQualify ListRest ListSetAt ListSort ListToArray ListValueCount ListValueCountNoCase LJustify Log </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Log10 LSCurrencyFormat LSDateFormat LSEuroCurrencyFormat LSIsCurrency LSIsDate LSIsNumeric LSNumberFormat LSParseCurrency LSParseDateTime </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">LSParseEuroCurrency LSParseNumber LSTimeFormat LTrim Max Mid Min Minute Month MonthAsString Now NumberFormat ParagraphFormat ParseDateTime </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Pi PrecisionEvaluate PreserveSingleQuotes Quarter QueryAddColumn QueryAddRow QueryConvertForGrid QueryNew QuerySetCell QuotedValueList Rand </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Randomize RandRange REFind REFindNoCase ReleaseComObject REMatch REMatchNoCase RemoveChars RepeatString Replace ReplaceList ReplaceNoCase </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">REReplace REReplaceNoCase Reverse Right RJustify Round RTrim Second SendGatewayMessage SerializeJSON SetEncoding SetLocale SetProfileString </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">SetVariable Sgn Sin Sleep SpanExcluding SpanIncluding Sqr StripCR StructAppend StructClear StructCopy StructCount StructDelete StructFind </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">StructFindKey StructFindValue StructGet StructInsert StructIsEmpty StructKeyArray StructKeyExists StructKeyList StructKeyList StructNew </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">StructSort StructUpdate Tan TimeFormat ToBase64 ToBinary ToScript ToString Trim UCase URLDecode URLEncodedFormat URLSessionFormat Val </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">ValueList VerifyClient Week Wrap Wrap WriteOutput XmlChildPos XmlElemNew XmlFormat XmlGetNodeType XmlNew XmlParse XmlSearch XmlTransform </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">XmlValidate Year YesNoFormat</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">cfabort cfajaximport cfajaxproxy cfapplet cfapplication cfargument cfassociate cfbreak cfcache cfcalendar </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">cfcase cfcatch cfchart cfchartdata cfchartseries cfcol cfcollection cfcomponent cfcontent cfcookie cfdbinfo </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">cfdefaultcase cfdirectory cfdiv cfdocument cfdocumentitem cfdocumentsection cfdump cfelse cfelseif cferror </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">cfexchangecalendar cfexchangeconnection cfexchangecontact cfexchangefilter cfexchangemail cfexchangetask </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">cfexecute cfexit cffeed cffile cfflush cfform cfformgroup cfformitem cfftp cffunction cfgrid cfgridcolumn </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">cfgridrow cfgridupdate cfheader cfhtmlhead cfhttp cfhttpparam cfif cfimage cfimport cfinclude cfindex </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">cfinput cfinsert cfinterface cfinvoke cfinvokeargument cflayout cflayoutarea cfldap cflocation cflock cflog </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">cflogin cfloginuser cflogout cfloop cfmail cfmailparam cfmailpart cfmenu cfmenuitem cfmodule cfNTauthenticate </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">cfobject cfobjectcache cfoutput cfparam cfpdf cfpdfform cfpdfformparam cfpdfparam cfpdfsubform cfpod cfpop </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">cfpresentation cfpresentationslide cfpresenter cfprint cfprocessingdirective cfprocparam cfprocresult </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">cfproperty cfquery cfqueryparam cfregistry cfreport cfreportparam cfrethrow cfreturn cfsavecontent cfschedule </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">cfscript cfsearch cfselect cfset cfsetting cfsilent cfslider cfsprydataset cfstoredproc cfswitch cftable </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">cftextarea cfthread cfthrow cftimer cftooltip cftrace cftransaction cftree cftreeitem cftry cfupdate cfwddx </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">cfwindow cfxml cfzip cfzipparam</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> operators = <span class="string"><span class="delimiter">'</span><span class="content">all and any between cross in join like not null or outer some</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">--(.*)$</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.xmlComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(funcs), <span class="string"><span class="delimiter">'</span><span class="content">gmi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">functions</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(operators), <span class="string"><span class="delimiter">'</span><span class="content">gmi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gmi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }];
        }

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">coldfusion</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">cf</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 27 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="comment">// Copyright 2006 Shin, YoungJin</span>

          <span class="keyword">var</span> datatypes = <span class="string"><span class="delimiter">'</span><span class="content">ATOM BOOL BOOLEAN BYTE CHAR COLORREF DWORD DWORDLONG DWORD_PTR </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">DWORD32 DWORD64 FLOAT HACCEL HALF_PTR HANDLE HBITMAP HBRUSH </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">HCOLORSPACE HCONV HCONVLIST HCURSOR HDC HDDEDATA HDESK HDROP HDWP </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">HENHMETAFILE HFILE HFONT HGDIOBJ HGLOBAL HHOOK HICON HINSTANCE HKEY </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">HKL HLOCAL HMENU HMETAFILE HMODULE HMONITOR HPALETTE HPEN HRESULT </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">HRGN HRSRC HSZ HWINSTA HWND INT INT_PTR INT32 INT64 LANGID LCID LCTYPE </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">LGRPID LONG LONGLONG LONG_PTR LONG32 LONG64 LPARAM LPBOOL LPBYTE LPCOLORREF </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">LPCSTR LPCTSTR LPCVOID LPCWSTR LPDWORD LPHANDLE LPINT LPLONG LPSTR LPTSTR </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">LPVOID LPWORD LPWSTR LRESULT PBOOL PBOOLEAN PBYTE PCHAR PCSTR PCTSTR PCWSTR </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">PDWORDLONG PDWORD_PTR PDWORD32 PDWORD64 PFLOAT PHALF_PTR PHANDLE PHKEY PINT </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">PINT_PTR PINT32 PINT64 PLCID PLONG PLONGLONG PLONG_PTR PLONG32 PLONG64 POINTER_32 </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">POINTER_64 PSHORT PSIZE_T PSSIZE_T PSTR PTBYTE PTCHAR PTSTR PUCHAR PUHALF_PTR </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">PUINT PUINT_PTR PUINT32 PUINT64 PULONG PULONGLONG PULONG_PTR PULONG32 PULONG64 </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">PUSHORT PVOID PWCHAR PWORD PWSTR SC_HANDLE SC_LOCK SERVICE_STATUS_HANDLE SHORT </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">SIZE_T SSIZE_T TBYTE TCHAR UCHAR UHALF_PTR UINT UINT_PTR UINT32 UINT64 ULONG </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">ULONGLONG ULONG_PTR ULONG32 ULONG64 USHORT USN VOID WCHAR WORD WPARAM WPARAM WPARAM </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">char char16_t char32_t bool short int __int32 __int64 __int8 __int16 long float double __wchar_t </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">clock_t _complex _dev_t _diskfree_t div_t ldiv_t _exception _EXCEPTION_POINTERS </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">FILE _finddata_t _finddatai64_t _wfinddata_t _wfinddatai64_t __finddata64_t </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">__wfinddata64_t _FPIEEE_RECORD fpos_t _HEAPINFO _HFILE lconv intptr_t </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">jmp_buf mbstate_t _off_t _onexit_t _PNH ptrdiff_t _purecall_handler </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">sig_atomic_t size_t _stat __stat64 _stati64 terminate_function </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">time_t __time64_t _timeb __timeb64 tm uintptr_t _utimbuf </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">va_list wchar_t wctrans_t wctype_t wint_t signed</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">alignas alignof auto break case catch class const constexpr decltype __finally __exception __try </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">const_cast continue private public protected __declspec </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">default delete deprecated dllexport dllimport do dynamic_cast </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">else enum explicit extern if for friend goto inline </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">mutable naked namespace new noinline noreturn nothrow noexcept nullptr </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">register reinterpret_cast return selectany </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">sizeof static static_cast static_assert struct switch template this </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">thread thread_local throw true false try typedef typeid typename union </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">using uuid virtual void volatile whcar_t while</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> functions = <span class="string"><span class="delimiter">'</span><span class="content">assert isalnum isalpha iscntrl isdigit isgraph islower isprint </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">ispunct isspace isupper isxdigit tolower toupper errno localeconv </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">setlocale acos asin atan atan2 ceil cos cosh exp fabs floor fmod </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">frexp ldexp log log10 modf pow sin sinh sqrt tan tanh jmp_buf </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">longjmp setjmp raise signal sig_atomic_t va_arg va_end va_start </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">clearerr fclose feof ferror fflush fgetc fgetpos fgets fopen </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">fprintf fputc fputs fread freopen fscanf fseek fsetpos ftell </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">fwrite getc getchar gets perror printf putc putchar puts remove </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">rename rewind scanf setbuf setvbuf sprintf sscanf tmpfile tmpnam </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">ungetc vfprintf vprintf vsprintf abort abs atexit atof atoi atol </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">bsearch calloc div exit free getenv labs ldiv malloc mblen mbstowcs </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">mbtowc qsort rand realloc srand strtod strtol strtoul system </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">wcstombs wctomb memchr memcmp memcpy memmove memset strcat strchr </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">strcmp strcoll strcpy strcspn strerror strlen strncat strncmp </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">strncpy strpbrk strrchr strspn strstr strtok strxfrm asctime </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">clock ctime difftime gmtime localtime mktime strftime time</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: regexLib.singleLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.multiLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">^ *#.*</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">preprocessor</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(datatypes), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1 bold</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(functions), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">functions bold</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword bold</span><span class="delimiter">'</span></span>
          }];
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">cpp</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">cc</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">c++</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">h</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">hpp</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">h++</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 28 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;
        <span class="keyword">var</span> Match = __webpack_require__(<span class="integer">5</span>).Match;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">abstract as base bool break byte case catch char checked class const </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">continue decimal default delegate do double else enum event explicit volatile </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">extern false finally fixed float for foreach get goto if implicit in int </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">interface internal is lock long namespace new null object operator out </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">override params private protected public readonly ref return sbyte sealed set </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">short sizeof stackalloc static string struct switch this throw true try </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">typeof uint ulong unchecked unsafe ushort using virtual void while var </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">from group by into select let where orderby join on equals ascending descending</span><span class="delimiter">'</span></span>;

          <span class="keyword">function</span> <span class="function">fixComments</span>(match, regexInfo) {
            <span class="keyword">var</span> css = match[<span class="integer">0</span>].indexOf(<span class="string"><span class="delimiter">&quot;</span><span class="content">///</span><span class="delimiter">&quot;</span></span>) == <span class="integer">0</span> ? <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span> : <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>;
            <span class="keyword">return</span> [<span class="keyword">new</span> Match(match[<span class="integer">0</span>], match.index, css)];
          }

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: regexLib.singleLineCComments,
            <span class="key">func</span>: fixComments
          }, {
            <span class="key">regex</span>: regexLib.multiLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">@&quot;(?:[^&quot;]|&quot;&quot;)*&quot;</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="char">\s</span><span class="content">*#.*</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">preprocessor</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">partial(?=</span><span class="char">\s</span><span class="content">+(?:class|interface|struct)</span><span class="char">\b</span><span class="content">)</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">yield(?=</span><span class="char">\s</span><span class="content">+(?:return|break)</span><span class="char">\b</span><span class="content">)</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }];

          <span class="local-variable">this</span>.forHtmlScript(regexLib.aspScriptTags);
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">c#</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">c-sharp</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">csharp</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 29 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="keyword">function</span> <span class="function">getKeywordsCSS</span>(str) {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">b([a-z_]|)</span><span class="delimiter">'</span></span> + str.replace(<span class="regexp"><span class="delimiter">/</span><span class="content"> </span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">(?=:)</span><span class="char">\\</span><span class="content">b|</span><span class="char">\\</span><span class="content">b([a-z_</span><span class="char">\\</span><span class="content">*]|</span><span class="char">\\</span><span class="content">*|)</span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content">(?=:)</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span>;
          };

          <span class="keyword">function</span> <span class="function">getValuesCSS</span>(str) {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span> + str.replace(<span class="regexp"><span class="delimiter">/</span><span class="content"> </span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">(?!-)(?!:)</span><span class="char">\\</span><span class="content">b|</span><span class="char">\\</span><span class="content">b()</span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content">\:</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span>;
          };

          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">ascent azimuth background-attachment background-color background-image background-position </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">background-repeat background baseline bbox border-collapse border-color border-spacing border-style border-top </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">border-right border-bottom border-left border-top-color border-right-color border-bottom-color border-left-color </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">border-top-style border-right-style border-bottom-style border-left-style border-top-width border-right-width </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">border-bottom-width border-left-width border-width border bottom cap-height caption-side centerline clear clip color </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">content counter-increment counter-reset cue-after cue-before cue cursor definition-src descent direction display </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">elevation empty-cells float font-size-adjust font-family font-size font-stretch font-style font-variant font-weight font </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">height left letter-spacing line-height list-style-image list-style-position list-style-type list-style margin-top </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">margin-right margin-bottom margin-left margin marker-offset marks mathline max-height max-width min-height min-width orphans </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">outline-color outline-style outline-width outline overflow padding-top padding-right padding-bottom padding-left padding page </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">page-break-after page-break-before page-break-inside pause pause-after pause-before pitch pitch-range play-during position </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">quotes right richness size slope src speak-header speak-numeral speak-punctuation speak speech-rate stemh stemv stress </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">table-layout text-align top text-decoration text-indent text-shadow text-transform unicode-bidi unicode-range units-per-em </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">vertical-align visibility voice-family volume white-space widows width widths word-spacing x-height z-index</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> values = <span class="string"><span class="delimiter">'</span><span class="content">above absolute all always aqua armenian attr aural auto avoid baseline behind below bidi-override black blink block blue bold bolder </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">both bottom braille capitalize caption center center-left center-right circle close-quote code collapse compact condensed </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">continuous counter counters crop cross crosshair cursive dashed decimal decimal-leading-zero default digits disc dotted double </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">embed embossed e-resize expanded extra-condensed extra-expanded fantasy far-left far-right fast faster fixed format fuchsia </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">gray green groove handheld hebrew help hidden hide high higher icon inline-table inline inset inside invert italic </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">justify landscape large larger left-side left leftwards level lighter lime line-through list-item local loud lower-alpha </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">lowercase lower-greek lower-latin lower-roman lower low ltr marker maroon medium message-box middle mix move narrower </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">navy ne-resize no-close-quote none no-open-quote no-repeat normal nowrap n-resize nw-resize oblique olive once open-quote outset </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">outside overline pointer portrait pre print projection purple red relative repeat repeat-x repeat-y rgb ridge right right-side </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">rightwards rtl run-in screen scroll semi-condensed semi-expanded separate se-resize show silent silver slower slow </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">small small-caps small-caption smaller soft solid speech spell-out square s-resize static status-bar sub super sw-resize </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">table-caption table-cell table-column table-column-group table-footer-group table-header-group table-row table-row-group teal </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">text-bottom text-top thick thin top transparent tty tv ultra-condensed ultra-expanded underline upper-alpha uppercase upper-latin </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">upper-roman url visible wait white wider w-resize x-fast x-high x-large x-loud x-low x-slow x-small x-soft xx-large xx-small yellow</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> fonts = <span class="string"><span class="delimiter">'</span><span class="content">[mM]onospace [tT]ahoma [vV]erdana [aA]rial [hH]elvetica [sS]ans-serif [sS]erif [cC]ourier mono sans serif</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: regexLib.multiLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\#</span><span class="content">[a-fA-F0-9]{3,6}</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(-?</span><span class="char">\d</span><span class="content">+)(</span><span class="content">\.</span><span class="char">\d</span><span class="content">+)?(px|em|pt|</span><span class="content">\:</span><span class="content">|</span><span class="content">\%</span><span class="content">|)</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">!important</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color3</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(getKeywordsCSS(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(getValuesCSS(values), <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(fonts), <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }];

          <span class="local-variable">this</span>.forHtmlScript({
            <span class="key">left</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(&amp;lt;|&lt;)</span><span class="char">\s</span><span class="content">*style.*?(&amp;gt;|&gt;)</span><span class="delimiter">/</span><span class="modifier">gi</span></span>,
            <span class="key">right</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(&amp;lt;|&lt;)</span><span class="content">\/</span><span class="char">\s</span><span class="content">*style</span><span class="char">\s</span><span class="content">*(&amp;gt;|&gt;)</span><span class="delimiter">/</span><span class="modifier">gi</span></span>
          });
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">css</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 30 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">abs addr and ansichar ansistring array as asm begin boolean byte cardinal </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">case char class comp const constructor currency destructor div do double </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">downto else end except exports extended false file finalization finally </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">for function goto if implementation in inherited int64 initialization </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">integer interface is label library longint longword mod nil not object </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">of on or packed pansichar pansistring pchar pcurrency pdatetime pextended </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">pint64 pointer private procedure program property pshortstring pstring </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">pvariant pwidechar pwidestring protected public published raise real real48 </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">record repeat set shl shortint shortstring shr single smallint string then </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">threadvar to true try type unit until uses val var varirnt while widechar </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">widestring with word write writeln xor</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\(</span><span class="content">\*</span><span class="content">[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?</span><span class="content">\*</span><span class="content">\)</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">{(?!</span><span class="content">\$</span><span class="content">)[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?}</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\{</span><span class="content">\$</span><span class="content">[a-zA-Z]+ .+</span><span class="content">\}</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">[</span><span class="char">\d</span><span class="content">\.</span><span class="content">]+</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\$</span><span class="content">[a-zA-Z0-9]+</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gmi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }];
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">delphi</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">pascal</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">pas</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 31 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="content">\+</span><span class="content">\+</span><span class="content">\+</span><span class="content"> .*$</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color2</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="content">\-</span><span class="content">\-</span><span class="content">\-</span><span class="content"> .*$</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color2</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="char">\s</span><span class="content">.*$</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">^@@.*@@.*$</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">variable</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="content">\+</span><span class="content">.*$</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="content">\-</span><span class="content">.*$</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color3</span><span class="delimiter">'</span></span>
          }];
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">diff</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">patch</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 32 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="comment">// Contributed by Jean-Lou Dupont</span>
          <span class="comment">// http://jldupont.blogspot.com/2009/06/erlang-syntax-highlighter.html</span>

          <span class="comment">// According to: http://erlang.org/doc/reference_manual/introduction.html#1.5</span>
          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">after and andalso band begin bnot bor bsl bsr bxor </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">case catch cond div end fun if let not of or orelse </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">query receive rem try when xor</span><span class="delimiter">'</span></span> +
          <span class="comment">// additional</span>
          <span class="string"><span class="delimiter">'</span><span class="content"> module export import define</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">&quot;</span><span class="content">[A-Z][A-Za-z0-9_]+</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">constants</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">&quot;</span><span class="char">\\</span><span class="content">%.+</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">&quot;</span><span class="char">\\</span><span class="content">?[A-Za-z0-9_]+</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">preprocessor</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">&quot;</span><span class="content">[a-z0-9_]+:[a-z0-9_]+</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">functions</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }];
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">erl</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">erlang</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 33 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="comment">// Contributed by Andres Almiray</span>
          <span class="comment">// http://jroller.com/aalmiray/entry/nice_source_code_syntax_highlighter</span>

          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">as assert break case catch class continue def default do else extends finally </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">if in implements import instanceof interface new package property return switch </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">throw throws try while public protected private static</span><span class="delimiter">'</span></span>;
          <span class="keyword">var</span> types = <span class="string"><span class="delimiter">'</span><span class="content">void boolean byte char short int long float double</span><span class="delimiter">'</span></span>;
          <span class="keyword">var</span> constants = <span class="string"><span class="delimiter">'</span><span class="content">null</span><span class="delimiter">'</span></span>;
          <span class="keyword">var</span> methods = <span class="string"><span class="delimiter">'</span><span class="content">allProperties count get size </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">collect each eachProperty eachPropertyName eachWithIndex find findAll </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">findIndexOf grep inject max min reverseEach sort </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">asImmutable asSynchronized flatten intersect join pop reverse subMap toList </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">padRight padLeft contains eachMatch toCharacter toLong toUrl tokenize </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">eachFile eachFileRecurse eachB yte eachLine readBytes readLine getText </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">splitEachLine withReader append encodeBase64 decodeBase64 filterLine </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">transformChar transformLine withOutputStream withPrintWriter withStream </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">withStreams withWriter withWriterAppend write writeLine </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">dump inspect invokeMethod print println step times upto use waitForOrKill </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">getText</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: regexLib.singleLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.multiLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">&quot;&quot;&quot;.*&quot;&quot;&quot;</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">b([</span><span class="char">\\</span><span class="content">d]+(</span><span class="char">\\</span><span class="content">.[</span><span class="char">\\</span><span class="content">d]+)?|0x[a-f0-9]+)</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(types), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(constants), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">constants</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(methods), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">functions</span><span class="delimiter">'</span></span>
          }];

          <span class="local-variable">this</span>.forHtmlScript(regexLib.aspScriptTags);
        }

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">groovy</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 34 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {

          <span class="keyword">var</span> inits = <span class="string"><span class="delimiter">'</span><span class="content">class interface package macro enum typedef extends implements dynamic in for if while else do try switch case catch</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">return break continue new throw cast using import function public private inline static untyped callback true false null Int Float String Void Std Bool Dynamic Array Vector</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: regexLib.singleLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.multiLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">([</span><span class="char">\d</span><span class="content">]+(</span><span class="content">\.</span><span class="content">[</span><span class="char">\d</span><span class="content">]+)?|0x[a-f0-9]+)</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">gi</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(inits), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color3</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">var</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">variable</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">trace</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">#if</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">#elseif</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">#end</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">#error</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }];

          <span class="comment">//standard compiler conditionals flags</span>
          <span class="keyword">var</span> flags = [<span class="string"><span class="delimiter">&quot;</span><span class="content">debug</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">cpp</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">js</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">neko</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">php</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">flash</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">flash8</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">flash9</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">flash10</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">flash10</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">mobile</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">desktop</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">web</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">ios</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">android</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">iphone</span><span class="delimiter">&quot;</span></span>];

          <span class="comment">//append the flags to the array with a ! operator</span>
          <span class="keyword">var</span> i;
          <span class="keyword">var</span> length = flags.length;
          <span class="keyword">for</span> (i = <span class="integer">0</span>; i &lt;= length - <span class="integer">1</span>; i++) {
            <span class="local-variable">this</span>.regexList.push({
              <span class="key">regex</span>: <span class="keyword">new</span> RegExp(flags[i], <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
              <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
            });
            <span class="local-variable">this</span>.regexList.push({
              <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">!</span><span class="delimiter">'</span></span> + flags[i], <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
              <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
            });
          }

          <span class="local-variable">this</span>.forHtmlScript(regexLib.scriptScriptTags);
        }

        ;

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">haxe</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">hx</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 35 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">abstract assert boolean break byte case catch char class const </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">continue default do double else enum extends </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">false final finally float for goto if implements import </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">instanceof int interface long native new null </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">package private protected public return </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">short static strictfp super switch synchronized this throw throws true </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">transient try void volatile while</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: regexLib.singleLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\/</span><span class="content">\*</span><span class="content">([^</span><span class="content">\*</span><span class="content">][</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?)?</span><span class="content">\*</span><span class="content">\/</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\/</span><span class="content">\*</span><span class="content">(?!</span><span class="content">\*</span><span class="content">\/</span><span class="content">)</span><span class="content">\*</span><span class="content">[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?</span><span class="content">\*</span><span class="content">\/</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">preprocessor</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">([</span><span class="char">\d</span><span class="content">]+(</span><span class="content">\.</span><span class="content">[</span><span class="char">\d</span><span class="content">]+)?f?|[</span><span class="char">\d</span><span class="content">]+l?|0x[a-f0-9]+)</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">gi</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(?!</span><span class="content">\@</span><span class="content">interface</span><span class="char">\b</span><span class="content">)</span><span class="content">\@</span><span class="content">[</span><span class="content">\$</span><span class="char">\w</span><span class="content">]+</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\@</span><span class="content">interface</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color2</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }];

          <span class="local-variable">this</span>.forHtmlScript({
            <span class="key">left</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(&amp;lt;|&lt;)%[@!=]?</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">right</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">%(&amp;gt;|&gt;)</span><span class="delimiter">/</span><span class="modifier">g</span></span>
          });
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 36 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="comment">// Contributed by Patrick Webster</span>
          <span class="comment">// http://patrickwebster.blogspot.com/2009/04/javafx-brush-for-syntaxhighlighter.html</span>
          <span class="keyword">var</span> datatypes = <span class="string"><span class="delimiter">'</span><span class="content">Boolean Byte Character Double Duration </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Float Integer Long Number Short String Void</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">abstract after and as assert at before bind bound break catch class </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">continue def delete else exclusive extends false finally first for from </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">function if import in indexof init insert instanceof into inverse last </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">lazy mixin mod nativearray new not null on or override package postinit </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">protected public public-init public-read replace return reverse sizeof </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">step super then this throw true try tween typeof var where while with </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">attribute let private readonly static trigger</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: regexLib.singleLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.multiLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(-?</span><span class="content">\.</span><span class="content">?)(</span><span class="char">\b</span><span class="content">(</span><span class="char">\d</span><span class="content">*</span><span class="content">\.</span><span class="content">?</span><span class="char">\d</span><span class="content">+|</span><span class="char">\d</span><span class="content">+</span><span class="content">\.</span><span class="content">?</span><span class="char">\d</span><span class="content">*)(e[+-]?</span><span class="char">\d</span><span class="content">+)?|0x[a-f</span><span class="char">\d</span><span class="content">]+)</span><span class="char">\b</span><span class="content">\.</span><span class="content">?</span><span class="delimiter">/</span><span class="modifier">gi</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color2</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(datatypes), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">variable</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }];
          <span class="local-variable">this</span>.forHtmlScript(regexLib.aspScriptTags);
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">jfx</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">javafx</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 37 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">break case catch class continue </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">default delete do else enum export extends false  </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">for from as function if implements import in instanceof </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">interface let new null package private protected </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">static return super switch </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">this throw true try typeof var while with yield</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: regexLib.multiLineDoubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.multiLineSingleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.multiLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\s</span><span class="content">*#.*</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">preprocessor</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }];

          <span class="local-variable">this</span>.forHtmlScript(regexLib.scriptScriptTags);
        }

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">js</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">jscript</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">javascript</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">json</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 38 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="comment">// Contributed by David Simmons-Duffin and Marty Kube</span>

          <span class="keyword">var</span> funcs = <span class="string"><span class="delimiter">'</span><span class="content">abs accept alarm atan2 bind binmode chdir chmod chomp chop chown chr </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">chroot close closedir connect cos crypt defined delete each endgrent </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">endhostent endnetent endprotoent endpwent endservent eof exec exists </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">exp fcntl fileno flock fork format formline getc getgrent getgrgid </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">getgrnam gethostbyaddr gethostbyname gethostent getlogin getnetbyaddr </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">getnetbyname getnetent getpeername getpgrp getppid getpriority </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">getprotobyname getprotobynumber getprotoent getpwent getpwnam getpwuid </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">getservbyname getservbyport getservent getsockname getsockopt glob </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">gmtime grep hex index int ioctl join keys kill lc lcfirst length link </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">listen localtime lock log lstat map mkdir msgctl msgget msgrcv msgsnd </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">oct open opendir ord pack pipe pop pos print printf prototype push </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">quotemeta rand read readdir readline readlink readpipe recv rename </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">reset reverse rewinddir rindex rmdir scalar seek seekdir select semctl </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">semget semop send setgrent sethostent setnetent setpgrp setpriority </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">setprotoent setpwent setservent setsockopt shift shmctl shmget shmread </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">shmwrite shutdown sin sleep socket socketpair sort splice split sprintf </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">sqrt srand stat study substr symlink syscall sysopen sysread sysseek </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">system syswrite tell telldir time times tr truncate uc ucfirst umask </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">undef unlink unpack unshift utime values vec wait waitpid warn write </span><span class="delimiter">'</span></span> +
          <span class="comment">// feature</span>
          <span class="string"><span class="delimiter">'</span><span class="content">say</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">bless caller continue dbmclose dbmopen die do dump else elsif eval exit </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">for foreach goto if import last local my next no our package redo ref </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">require return sub tie tied unless untie until use wantarray while </span><span class="delimiter">'</span></span> +
          <span class="comment">// feature</span>
          <span class="string"><span class="delimiter">'</span><span class="content">given when default </span><span class="delimiter">'</span></span> +
          <span class="comment">// Try::Tiny</span>
          <span class="string"><span class="delimiter">'</span><span class="content">try catch finally </span><span class="delimiter">'</span></span> +
          <span class="comment">// Moose</span>
          <span class="string"><span class="delimiter">'</span><span class="content">has extends with before after around override augment</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(&lt;&lt;|&amp;lt;&amp;lt;)((</span><span class="char">\w</span><span class="content">+)|(['&quot;])(.+?)</span><span class="char">\4</span><span class="content">)[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]+?</span><span class="char">\n</span><span class="char">\3</span><span class="char">\5</span><span class="char">\n</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">#.*$</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">^#!.*</span><span class="char">\n</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">preprocessor</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">-?</span><span class="char">\w</span><span class="content">+(?=</span><span class="char">\s</span><span class="content">*=(&gt;|&amp;gt;))</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          },

          <span class="comment">// is this too much?</span>
          {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">q[qwxr]?</span><span class="content">\(</span><span class="content">[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?</span><span class="content">\)</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">q[qwxr]?</span><span class="content">\{</span><span class="content">[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?</span><span class="content">\}</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">q[qwxr]?</span><span class="content">\[</span><span class="content">[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?</span><span class="content">\]</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">q[qwxr]?(&lt;|&amp;lt;)[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?(&gt;|&amp;gt;)</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">q[qwxr]?([^</span><span class="char">\w</span><span class="content">({&lt;[])[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?</span><span class="char">\1</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(?:&amp;amp;|[$@%*]|</span><span class="content">\$</span><span class="content">#)</span><span class="content">\$</span><span class="content">?[a-zA-Z_](</span><span class="char">\w</span><span class="content">+|::)*</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">variable</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">__(?:END|DATA)__</span><span class="char">\b</span><span class="content">[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*$</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(^|</span><span class="char">\n</span><span class="content">)=</span><span class="char">\w</span><span class="content">[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?(</span><span class="char">\n</span><span class="content">=cut</span><span class="char">\s</span><span class="content">*(?=</span><span class="char">\n</span><span class="content">)|$)</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(funcs), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">functions</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }];

          <span class="local-variable">this</span>.forHtmlScript(regexLib.phpScriptTags);
        }

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">perl</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Perl</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">pl</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 39 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        Object.defineProperty(exports, <span class="string"><span class="delimiter">&quot;</span><span class="content">__esModule</span><span class="delimiter">&quot;</span></span>, {
          <span class="key">value</span>: <span class="predefined-constant">true</span>
        });

        <span class="keyword">var</span> <span class="function">_createClass</span> = <span class="keyword">function</span> () { <span class="keyword">function</span> <span class="function">defineProperties</span>(target, props) { <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>; i &lt; props.length; i++) { <span class="keyword">var</span> descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || <span class="predefined-constant">false</span>; descriptor.configurable = <span class="predefined-constant">true</span>; <span class="keyword">if</span> (<span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="predefined-constant">true</span>; Object.defineProperty(target, descriptor.key, descriptor); } } <span class="keyword">return</span> <span class="keyword">function</span> (Constructor, protoProps, staticProps) { <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps); <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps); <span class="keyword">return</span> Constructor; }; }();

        <span class="keyword">var</span> _brushBase = __webpack_require__(<span class="integer">22</span>);

        <span class="keyword">var</span> _brushBase2 = _interopRequireDefault(_brushBase);

        <span class="keyword">var</span> _syntaxhighlighterRegex = __webpack_require__(<span class="integer">3</span>);

        <span class="keyword">function</span> <span class="function">_interopRequireDefault</span>(obj) { <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : { <span class="keyword">default</span>: obj }; }

        <span class="keyword">function</span> <span class="function">_classCallCheck</span>(instance, Constructor) { <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) { <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string"><span class="delimiter">&quot;</span><span class="content">Cannot call a class as a function</span><span class="delimiter">&quot;</span></span>); } }

        <span class="keyword">function</span> <span class="function">_possibleConstructorReturn</span>(self, call) { <span class="keyword">if</span> (!self) { <span class="keyword">throw</span> <span class="keyword">new</span> ReferenceError(<span class="string"><span class="delimiter">&quot;</span><span class="content">this hasn't been initialised - super() hasn't been called</span><span class="delimiter">&quot;</span></span>); } <span class="keyword">return</span> call &amp;&amp; (<span class="keyword">typeof</span> call === <span class="string"><span class="delimiter">&quot;</span><span class="content">object</span><span class="delimiter">&quot;</span></span> || <span class="keyword">typeof</span> call === <span class="string"><span class="delimiter">&quot;</span><span class="content">function</span><span class="delimiter">&quot;</span></span>) ? call : self; }

        <span class="keyword">function</span> <span class="function">_inherits</span>(subClass, superClass) { <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string"><span class="delimiter">&quot;</span><span class="content">function</span><span class="delimiter">&quot;</span></span> &amp;&amp; superClass !== <span class="predefined-constant">null</span>) { <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string"><span class="delimiter">&quot;</span><span class="content">Super expression must either be null or a function, not </span><span class="delimiter">&quot;</span></span> + <span class="keyword">typeof</span> superClass); } subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { <span class="key">constructor</span>: { <span class="key">value</span>: subClass, <span class="key">enumerable</span>: <span class="predefined-constant">false</span>, <span class="key">writable</span>: <span class="predefined-constant">true</span>, <span class="key">configurable</span>: <span class="predefined-constant">true</span> } }); <span class="keyword">if</span> (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

        <span class="keyword">var</span> functions = <span class="string"><span class="delimiter">'</span><span class="content">abs acos acosh addcslashes addslashes </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">array_change_key_case array_chunk array_combine array_count_values array_diff </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">array_diff_assoc array_diff_key array_diff_uassoc array_diff_ukey array_fill </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">array_filter array_flip array_intersect array_intersect_assoc array_intersect_key </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">array_intersect_uassoc array_intersect_ukey array_key_exists array_keys array_map </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">array_merge array_merge_recursive array_multisort array_pad array_pop array_product </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">array_push array_rand array_reduce array_reverse array_search array_shift </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">array_slice array_splice array_sum array_udiff array_udiff_assoc </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">array_udiff_uassoc array_uintersect array_uintersect_assoc </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">array_uintersect_uassoc array_unique array_unshift array_values array_walk </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">array_walk_recursive atan atan2 atanh base64_decode base64_encode base_convert </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">basename bcadd bccomp bcdiv bcmod bcmul bindec bindtextdomain bzclose bzcompress </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">bzdecompress bzerrno bzerror bzerrstr bzflush bzopen bzread bzwrite ceil chdir </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">checkdate checkdnsrr chgrp chmod chop chown chr chroot chunk_split class_exists </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">closedir closelog copy cos cosh count count_chars date decbin dechex decoct </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">deg2rad delete ebcdic2ascii echo empty end ereg ereg_replace eregi eregi_replace error_log </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">error_reporting escapeshellarg escapeshellcmd eval exec exit exp explode extension_loaded </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">feof fflush fgetc fgetcsv fgets fgetss file_exists file_get_contents file_put_contents </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">fileatime filectime filegroup fileinode filemtime fileowner fileperms filesize filetype </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">floatval flock floor flush fmod fnmatch fopen fpassthru fprintf fputcsv fputs fread fscanf </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">fseek fsockopen fstat ftell ftok getallheaders getcwd getdate getenv gethostbyaddr gethostbyname </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">gethostbynamel getimagesize getlastmod getmxrr getmygid getmyinode getmypid getmyuid getopt </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">getprotobyname getprotobynumber getrandmax getrusage getservbyname getservbyport gettext </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">gettimeofday gettype glob gmdate gmmktime ini_alter ini_get ini_get_all ini_restore ini_set </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">interface_exists intval ip2long is_a is_array is_bool is_callable is_dir is_double </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">is_executable is_file is_finite is_float is_infinite is_int is_integer is_link is_long </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">is_nan is_null is_numeric is_object is_readable is_real is_resource is_scalar is_soap_fault </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">is_string is_subclass_of is_uploaded_file is_writable is_writeable mkdir mktime nl2br </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">parse_ini_file parse_str parse_url passthru pathinfo print readlink realpath rewind rewinddir rmdir </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">round str_ireplace str_pad str_repeat str_replace str_rot13 str_shuffle str_split </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">str_word_count strcasecmp strchr strcmp strcoll strcspn strftime strip_tags stripcslashes </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">stripos stripslashes stristr strlen strnatcasecmp strnatcmp strncasecmp strncmp strpbrk </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">strpos strptime strrchr strrev strripos strrpos strspn strstr strtok strtolower strtotime </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">strtoupper strtr strval substr substr_compare</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">abstract and array as break case catch cfunction class clone const continue declare default die do </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">else elseif enddeclare endfor endforeach endif endswitch endwhile extends final finally for foreach </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">function global goto if implements include include_once interface instanceof insteadof namespace new </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">old_function or private protected public return require require_once static switch </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">trait throw try use const while xor yield </span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> constants = <span class="string"><span class="delimiter">'</span><span class="content">__FILE__ __LINE__ __METHOD__ __FUNCTION__ __CLASS__</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> <span class="function">Brush</span> = <span class="keyword">function</span> (_BrushBase) {
          _inherits(Brush, _BrushBase);

          _createClass(Brush, <span class="predefined-constant">null</span>, [{
            <span class="key">key</span>: <span class="string"><span class="delimiter">'</span><span class="content">aliases</span><span class="delimiter">'</span></span>,
            <span class="function">get</span>: <span class="keyword">function</span> <span class="function">get</span>() {
              <span class="keyword">return</span> [<span class="string"><span class="delimiter">'</span><span class="content">php</span><span class="delimiter">'</span></span>];
            }
          }]);

          <span class="keyword">function</span> <span class="function">Brush</span>() {
            _classCallCheck(<span class="local-variable">this</span>, Brush);

            <span class="keyword">var</span> _this = _possibleConstructorReturn(<span class="local-variable">this</span>, Object.getPrototypeOf(Brush).call(<span class="local-variable">this</span>));

            _this.regexList = [{ <span class="key">regex</span>: _syntaxhighlighterRegex.commonRegExp.singleLineCComments, <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span> }, { <span class="key">regex</span>: _syntaxhighlighterRegex.commonRegExp.multiLineCComments, <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span> }, { <span class="key">regex</span>: _syntaxhighlighterRegex.commonRegExp.doubleQuotedString, <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span> }, { <span class="key">regex</span>: _syntaxhighlighterRegex.commonRegExp.singleQuotedString, <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span> }, { <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\$</span><span class="char">\w</span><span class="content">+</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">variable</span><span class="delimiter">'</span></span> }, { <span class="key">regex</span>: <span class="keyword">new</span> RegExp(_this.getKeywords(functions), <span class="string"><span class="delimiter">'</span><span class="content">gmi</span><span class="delimiter">'</span></span>), <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">functions</span><span class="delimiter">'</span></span> }, { <span class="key">regex</span>: <span class="keyword">new</span> RegExp(_this.getKeywords(constants), <span class="string"><span class="delimiter">'</span><span class="content">gmi</span><span class="delimiter">'</span></span>), <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">constants</span><span class="delimiter">'</span></span> }, { <span class="key">regex</span>: <span class="keyword">new</span> RegExp(_this.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>), <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span> }];

            _this.forHtmlScript(_syntaxhighlighterRegex.commonRegExp.phpScriptTags);
            <span class="keyword">return</span> _this;
          }

          <span class="keyword">return</span> Brush;
        }(_brushBase2.<span class="keyword">default</span>);

        exports.<span class="keyword">default</span> = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 40 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="local-variable">this</span>.regexList = [];
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">plain</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 41 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="comment">// Contributed by Joel 'Jaykul' Bennett, http://PoshCode.org | http://HuddledMasses.org</span>
          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">while validateset validaterange validatepattern validatelength validatecount </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">until trap switch return ref process param parameter in if global: </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">function foreach for finally filter end elseif else dynamicparam do default </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">continue cmdletbinding break begin alias </span><span class="char">\\</span><span class="content">? % #script #private #local #global </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">mandatory parametersetname position valuefrompipeline </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">valuefrompipelinebypropertyname valuefromremainingarguments helpmessage </span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> operators = <span class="string"><span class="delimiter">'</span><span class="content"> and as band bnot bor bxor casesensitive ccontains ceq cge cgt cle </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">clike clt cmatch cne cnotcontains cnotlike cnotmatch contains </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">creplace eq exact f file ge gt icontains ieq ige igt ile ilike ilt </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">imatch ine inotcontains inotlike inotmatch ireplace is isnot le like </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">lt match ne not notcontains notlike notmatch or regex replace wildcard</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> verbs = <span class="string"><span class="delimiter">'</span><span class="content">write where wait use update unregister undo trace test tee take suspend </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">stop start split sort skip show set send select scroll resume restore </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">restart resolve resize reset rename remove register receive read push </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">pop ping out new move measure limit join invoke import group get format </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">foreach export expand exit enter enable disconnect disable debug cxnew </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">copy convertto convertfrom convert connect complete compare clear </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">checkpoint aggregate add</span><span class="delimiter">'</span></span>;

          <span class="comment">// I can't find a way to match the comment based help in multi-line comments, because SH won't highlight in highlights, and javascript doesn't support lookbehind</span>
          <span class="keyword">var</span> commenthelp = <span class="string"><span class="delimiter">'</span><span class="content"> component description example externalhelp forwardhelpcategory forwardhelptargetname forwardhelptargetname functionality inputs link notes outputs parameter remotehelprunspace role synopsis</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">^</span><span class="char">\\</span><span class="content">s*#[#</span><span class="char">\\</span><span class="content">s]*</span><span class="char">\\</span><span class="content">.(</span><span class="delimiter">'</span></span> + <span class="local-variable">this</span>.getKeywords(commenthelp) + <span class="string"><span class="delimiter">'</span><span class="content">).*$</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gim</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">preprocessor help bold</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleLinePerlComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(&amp;lt;|&lt;)#[</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?#(&amp;gt;|&gt;)</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments here</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">@&quot;</span><span class="char">\\</span><span class="content">n[</span><span class="char">\\</span><span class="content">s</span><span class="char">\\</span><span class="content">S]*?</span><span class="char">\\</span><span class="content">n&quot;@</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">script string here</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">&quot;</span><span class="content">@'</span><span class="char">\\</span><span class="content">n[</span><span class="char">\\</span><span class="content">s</span><span class="char">\\</span><span class="content">S]*?</span><span class="char">\\</span><span class="content">n'@</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">script string single here</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">&quot;(?:</span><span class="char">\\</span><span class="content">$</span><span class="char">\\</span><span class="content">([^</span><span class="char">\\</span><span class="content">)]*</span><span class="char">\\</span><span class="content">)|[^&quot;]|`&quot;|&quot;&quot;)*[^`]&quot;</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">&quot;</span><span class="content">'(?:[^']|'')*'</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string single</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">[</span><span class="char">\\</span><span class="content">$|@|@@](?:(?:global|script|private|env):)?[A-Z0-9_]+</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">variable</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">(?:</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span> + verbs.replace(<span class="regexp"><span class="delimiter">/</span><span class="content"> </span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">b|</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content">)-[a-zA-Z_][a-zA-Z0-9_]*</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gmi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">functions</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gmi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">-</span><span class="delimiter">'</span></span> + <span class="local-variable">this</span>.getKeywords(operators), <span class="string"><span class="delimiter">'</span><span class="content">gmi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">operator value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">[[A-Z_</span><span class="char">\\</span><span class="content">[][A-Z0-9_. `,</span><span class="char">\\</span><span class="content">[</span><span class="char">\\</span><span class="content">]]*</span><span class="char">\\</span><span class="content">]</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">constants</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">s+-(?!</span><span class="delimiter">'</span></span> + <span class="local-variable">this</span>.getKeywords(operators) + <span class="string"><span class="delimiter">'</span><span class="content">)[a-zA-Z_][a-zA-Z0-9_]*</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gmi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }];
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">powershell</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">ps</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">posh</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 42 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="comment">// Contributed by Gheorghe Milas and Ahmad Sherif</span>

          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">and assert break class continue def del elif else </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">except exec finally for from global if import in is </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">lambda not or pass raise return try yield while</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> funcs = <span class="string"><span class="delimiter">'</span><span class="content">__import__ abs all any apply basestring bin bool buffer callable </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">chr classmethod cmp coerce compile complex delattr dict dir </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">divmod enumerate eval execfile file filter float format frozenset </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">getattr globals hasattr hash help hex id input int intern </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">isinstance issubclass iter len list locals long map max min next </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">object oct open ord pow print property range raw_input reduce </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">reload repr reversed round set setattr slice sorted staticmethod </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">str sum super tuple type type unichr unicode vars xrange zip</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> special = <span class="string"><span class="delimiter">'</span><span class="content">None True False self cls class_</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: regexLib.singleLinePerlComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="char">\s</span><span class="content">*@</span><span class="char">\w</span><span class="content">+</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">decorator</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(['</span><span class="char">\&quot;</span><span class="content">]{3})([^</span><span class="char">\1</span><span class="content">])*?</span><span class="char">\1</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">&quot;(?!&quot;)(?:</span><span class="content">\.</span><span class="content">|</span><span class="char">\\</span><span class="char">\&quot;</span><span class="content">|[^</span><span class="char">\&quot;</span><span class="content">&quot;</span><span class="char">\n</span><span class="content">])*&quot;</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">'(?!')(?:</span><span class="content">\.</span><span class="content">|(</span><span class="char">\\</span><span class="char">\'</span><span class="content">)|[^</span><span class="char">\'</span><span class="content">'</span><span class="char">\n</span><span class="content">])*'</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\+</span><span class="content">|</span><span class="content">\-</span><span class="content">|</span><span class="content">\*</span><span class="content">|</span><span class="content">\/</span><span class="content">|</span><span class="content">\%</span><span class="content">|=|==</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="char">\d</span><span class="content">+</span><span class="content">\.</span><span class="content">?</span><span class="char">\w</span><span class="content">*</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(funcs), <span class="string"><span class="delimiter">'</span><span class="content">gmi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">functions</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(special), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }];

          <span class="local-variable">this</span>.forHtmlScript(regexLib.aspScriptTags);
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">py</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">python</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 43 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="comment">// Contributed by Erik Peterson.</span>

          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">alias and BEGIN begin break case class def define_method defined do each else elsif </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">END end ensure false for if in module new next nil not or raise redo rescue retry return </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">self super then throw true undef unless until when while yield</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> builtins = <span class="string"><span class="delimiter">'</span><span class="content">Array Bignum Binding Class Continuation Dir Exception FalseClass File::Stat File Fixnum Fload </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Hash Integer IO MatchData Method Module NilClass Numeric Object Proc Range Regexp String Struct::TMS Symbol </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">ThreadGroup Thread Time TrueClass</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: regexLib.singleLinePerlComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">[A-Z0-9_]+</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">constants</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">:[a-z][A-Za-z0-9_]*</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color2</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">(</span><span class="content">\$</span><span class="content">|@@|@)</span><span class="char">\w</span><span class="content">+</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">variable bold</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(builtins), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }];

          <span class="local-variable">this</span>.forHtmlScript(regexLib.aspScriptTags);
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">ruby</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">rails</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">ror</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">rb</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 44 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="keyword">function</span> <span class="function">getKeywordsCSS</span>(str) {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">b([a-z_]|)</span><span class="delimiter">'</span></span> + str.replace(<span class="regexp"><span class="delimiter">/</span><span class="content"> </span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">(?=:)</span><span class="char">\\</span><span class="content">b|</span><span class="char">\\</span><span class="content">b([a-z_</span><span class="char">\\</span><span class="content">*]|</span><span class="char">\\</span><span class="content">*|)</span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content">(?=:)</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span>;
          };

          <span class="keyword">function</span> <span class="function">getValuesCSS</span>(str) {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span> + str.replace(<span class="regexp"><span class="delimiter">/</span><span class="content"> </span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">(?!-)(?!:)</span><span class="char">\\</span><span class="content">b|</span><span class="char">\\</span><span class="content">b()</span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content">\:</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span>;
          };

          <span class="keyword">function</span> <span class="function">getKeywordsPrependedBy</span>(keywords, by) {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="content">(?:</span><span class="delimiter">'</span></span> + keywords.replace(<span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="char">\s</span><span class="content">+|</span><span class="char">\s</span><span class="content">+$</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>).replace(<span class="regexp"><span class="delimiter">/</span><span class="char">\s</span><span class="content">+</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">|</span><span class="delimiter">'</span></span> + by + <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span>).replace(<span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="delimiter">/</span></span>, by + <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content">)</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span>;
          }

          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">ascent azimuth background-attachment background-color background-image background-position </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">background-repeat background baseline bbox border-collapse border-color border-spacing border-style border-top </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">border-right border-bottom border-left border-top-color border-right-color border-bottom-color border-left-color </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">border-top-style border-right-style border-bottom-style border-left-style border-top-width border-right-width </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">border-bottom-width border-left-width border-width border bottom cap-height caption-side centerline clear clip color </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">content counter-increment counter-reset cue-after cue-before cue cursor definition-src descent direction display </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">elevation empty-cells float font-size-adjust font-family font-size font-stretch font-style font-variant font-weight font </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">height left letter-spacing line-height list-style-image list-style-position list-style-type list-style margin-top </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">margin-right margin-bottom margin-left margin marker-offset marks mathline max-height max-width min-height min-width orphans </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">outline-color outline-style outline-width outline overflow padding-top padding-right padding-bottom padding-left padding page </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">page-break-after page-break-before page-break-inside pause pause-after pause-before pitch pitch-range play-during position </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">quotes right richness size slope src speak-header speak-numeral speak-punctuation speak speech-rate stemh stemv stress </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">table-layout text-align top text-decoration text-indent text-shadow text-transform unicode-bidi unicode-range units-per-em </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">vertical-align visibility voice-family volume white-space widows width widths word-spacing x-height z-index zoom</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> values = <span class="string"><span class="delimiter">'</span><span class="content">above absolute all always aqua armenian attr aural auto avoid baseline behind below bidi-override black blink block blue bold bolder </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">both bottom braille capitalize caption center center-left center-right circle close-quote code collapse compact condensed </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">continuous counter counters crop cross crosshair cursive dashed decimal decimal-leading-zero digits disc dotted double </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">embed embossed e-resize expanded extra-condensed extra-expanded fantasy far-left far-right fast faster fixed format fuchsia </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">gray green groove handheld hebrew help hidden hide high higher icon inline-table inline inset inside invert italic </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">justify landscape large larger left-side left leftwards level lighter lime line-through list-item local loud lower-alpha </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">lowercase lower-greek lower-latin lower-roman lower low ltr marker maroon medium message-box middle mix move narrower </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">navy ne-resize no-close-quote none no-open-quote no-repeat normal nowrap n-resize nw-resize oblique olive once open-quote outset </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">outside overline pointer portrait pre print projection purple red relative repeat repeat-x repeat-y rgb ridge right right-side </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">rightwards rtl run-in screen scroll semi-condensed semi-expanded separate se-resize show silent silver slower slow </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">small small-caps small-caption smaller soft solid speech spell-out square s-resize static status-bar sub super sw-resize </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">table-caption table-cell table-column table-column-group table-footer-group table-header-group table-row table-row-group teal </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">text-bottom text-top thick thin top transparent tty tv ultra-condensed ultra-expanded underline upper-alpha uppercase upper-latin </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">upper-roman url visible wait white wider w-resize x-fast x-high x-large x-loud x-low x-slow x-small x-soft xx-large xx-small yellow</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> fonts = <span class="string"><span class="delimiter">'</span><span class="content">[mM]onospace [tT]ahoma [vV]erdana [aA]rial [hH]elvetica [sS]ans-serif [sS]erif [cC]ourier mono sans serif</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> statements = <span class="string"><span class="delimiter">'</span><span class="content">important default</span><span class="delimiter">'</span></span>;
          <span class="keyword">var</span> preprocessor = <span class="string"><span class="delimiter">'</span><span class="content">import extend debug warn if else for while mixin function include content media</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> r = regexLib;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: r.multiLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: r.singleLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: r.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: r.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\#</span><span class="content">[a-fA-F0-9]{3,6}</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="char">\b</span><span class="content">(-?</span><span class="char">\d</span><span class="content">+)(</span><span class="content">\.</span><span class="char">\d</span><span class="content">+)?(px|em|rem|pt|</span><span class="content">\:</span><span class="content">|</span><span class="content">\%</span><span class="content">|)</span><span class="char">\b</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\$</span><span class="content">[</span><span class="char">\w</span><span class="content">-]+</span><span class="delimiter">/</span><span class="modifier">g</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">variable</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(getKeywordsPrependedBy(statements, <span class="string"><span class="delimiter">'</span><span class="content">!</span><span class="delimiter">'</span></span>), <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color3</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(getKeywordsPrependedBy(preprocessor, <span class="string"><span class="delimiter">'</span><span class="content">@</span><span class="delimiter">'</span></span>), <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">preprocessor</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(getKeywordsCSS(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(getValuesCSS(values), <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(fonts), <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }];
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">sass</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">scss</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 45 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="comment">// Contributed by Yegor Jbanov and David Bernard.</span>

          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">val sealed case def true trait implicit forSome import match object null finally super </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">override try lazy for var catch throw type extends class while with new final yield abstract </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">else do if return protected private this package false</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> keyops = <span class="string"><span class="delimiter">'</span><span class="content">[_:=&gt;&lt;%#@]+</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: regexLib.singleLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.multiLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.multiLineSingleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.multiLineDoubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">0x[a-f0-9]+|</span><span class="char">\d</span><span class="content">+(</span><span class="content">\.</span><span class="char">\d</span><span class="content">+)?</span><span class="delimiter">/</span><span class="modifier">gi</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(keyops, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }];
        }

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">scala</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 46 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="keyword">var</span> funcs = <span class="string"><span class="delimiter">'</span><span class="content">abs avg case cast coalesce convert count current_timestamp </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">current_user day isnull left lower month nullif replace right </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">session_user space substring sum system_user upper user year</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">absolute action add after alter as asc at authorization begin bigint </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">binary bit by cascade char character check checkpoint close collate </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">column commit committed connect connection constraint contains continue </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">create cube current current_date current_time cursor database date </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">deallocate dec decimal declare default delete desc distinct double drop </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">dynamic else end end-exec escape except exec execute false fetch first </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">float for force foreign forward free from full function global goto grant </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">group grouping having hour ignore index inner insensitive insert instead </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">int integer intersect into is isolation key last level load local max min </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">minute modify move name national nchar next no numeric of off on only </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">open option order out output partial password precision prepare primary </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">prior privileges procedure public read real references relative repeatable </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">restrict return returns revoke rollback rollup rows rule schema scroll </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">second section select sequence serializable set size smallint static </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">statistics table temp temporary then time timestamp to top transaction </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">translation trigger true truncate uncommitted union unique update values </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">varchar varying view when where with work</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> operators = <span class="string"><span class="delimiter">'</span><span class="content">all and any between cross in join like not null or outer some</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">--(.*)$</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">\/</span><span class="content">\*</span><span class="content">([^</span><span class="content">\*</span><span class="content">][</span><span class="char">\s</span><span class="char">\S</span><span class="content">]*?)?</span><span class="content">\*</span><span class="content">\/</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.multiLineDoubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.multiLineSingleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(funcs), <span class="string"><span class="delimiter">'</span><span class="content">gmi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color2</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(operators), <span class="string"><span class="delimiter">'</span><span class="content">gmi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gmi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }];
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">sql</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 47 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;
        <span class="keyword">var</span> Match = __webpack_require__(<span class="integer">5</span>).Match;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="comment">// Swift brush contributed by Nate Cook</span>
          <span class="comment">// http://natecook.com/code/swift-syntax-highlighting</span>

          <span class="keyword">function</span> <span class="function">getKeywordsPrependedBy</span>(keywords, by) {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="content">(?:</span><span class="delimiter">'</span></span> + keywords.replace(<span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="char">\s</span><span class="content">+|</span><span class="char">\s</span><span class="content">+$</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span>).replace(<span class="regexp"><span class="delimiter">/</span><span class="char">\s</span><span class="content">+</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">|</span><span class="delimiter">'</span></span> + by + <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span>).replace(<span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="delimiter">/</span></span>, by + <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span>) + <span class="string"><span class="delimiter">'</span><span class="content">)</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span>;
          }

          <span class="keyword">function</span> <span class="function">multiLineCCommentsAdd</span>(match, regexInfo) {
            <span class="keyword">var</span> str = match[<span class="integer">0</span>],
                result = [],
                pos = <span class="integer">0</span>,
                matchStart = <span class="integer">0</span>,
                level = <span class="integer">0</span>;

            <span class="keyword">while</span> (pos &lt; str.length - <span class="integer">1</span>) {
              <span class="keyword">var</span> chunk = str.substr(pos, <span class="integer">2</span>);
              <span class="keyword">if</span> (level == <span class="integer">0</span>) {
                <span class="keyword">if</span> (chunk == <span class="string"><span class="delimiter">&quot;</span><span class="content">/*</span><span class="delimiter">&quot;</span></span>) {
                  matchStart = pos;
                  level++;
                  pos += <span class="integer">2</span>;
                } <span class="keyword">else</span> {
                  pos++;
                }
              } <span class="keyword">else</span> {
                <span class="keyword">if</span> (chunk == <span class="string"><span class="delimiter">&quot;</span><span class="content">/*</span><span class="delimiter">&quot;</span></span>) {
                  level++;
                  pos += <span class="integer">2</span>;
                } <span class="keyword">else</span> <span class="keyword">if</span> (chunk == <span class="string"><span class="delimiter">&quot;</span><span class="content">*/</span><span class="delimiter">&quot;</span></span>) {
                  level--;
                  <span class="keyword">if</span> (level == <span class="integer">0</span>) {
                    result.push(<span class="keyword">new</span> Match(str.substring(matchStart, pos + <span class="integer">2</span>), matchStart + match.index, regexInfo.css));
                  }
                  pos += <span class="integer">2</span>;
                } <span class="keyword">else</span> {
                  pos++;
                }
              }
            }

            <span class="keyword">return</span> result;
          }

          <span class="keyword">function</span> <span class="function">stringAdd</span>(match, regexInfo) {
            <span class="keyword">var</span> str = match[<span class="integer">0</span>],
                result = [],
                pos = <span class="integer">0</span>,
                matchStart = <span class="integer">0</span>,
                level = <span class="integer">0</span>;

            <span class="keyword">while</span> (pos &lt; str.length - <span class="integer">1</span>) {
              <span class="keyword">if</span> (level == <span class="integer">0</span>) {
                <span class="keyword">if</span> (str.substr(pos, <span class="integer">2</span>) == <span class="string"><span class="delimiter">&quot;</span><span class="char">\\</span><span class="content">(</span><span class="delimiter">&quot;</span></span>) {
                  result.push(<span class="keyword">new</span> Match(str.substring(matchStart, pos + <span class="integer">2</span>), matchStart + match.index, regexInfo.css));
                  level++;
                  pos += <span class="integer">2</span>;
                } <span class="keyword">else</span> {
                  pos++;
                }
              } <span class="keyword">else</span> {
                <span class="keyword">if</span> (str[pos] == <span class="string"><span class="delimiter">&quot;</span><span class="content">(</span><span class="delimiter">&quot;</span></span>) {
                  level++;
                }
                <span class="keyword">if</span> (str[pos] == <span class="string"><span class="delimiter">&quot;</span><span class="content">)</span><span class="delimiter">&quot;</span></span>) {
                  level--;
                  <span class="keyword">if</span> (level == <span class="integer">0</span>) {
                    matchStart = pos;
                  }
                }
                pos++;
              }
            }
            <span class="keyword">if</span> (level == <span class="integer">0</span>) {
              result.push(<span class="keyword">new</span> Match(str.substring(matchStart, str.length), matchStart + match.index, regexInfo.css));
            }

            <span class="keyword">return</span> result;
          };

          <span class="comment">// &quot;Swift-native types&quot; are all the protocols, classes, structs, enums, funcs, vars, and typealiases built into the language</span>
          <span class="keyword">var</span> swiftTypes = <span class="string"><span class="delimiter">'</span><span class="content">AbsoluteValuable Any AnyClass Array ArrayBound ArrayBuffer ArrayBufferType ArrayLiteralConvertible ArrayType AutoreleasingUnsafePointer BidirectionalIndex Bit BitwiseOperations Bool C CBool CChar CChar16 CChar32 CConstPointer CConstVoidPointer CDouble CFloat CInt CLong CLongLong CMutablePointer CMutableVoidPointer COpaquePointer CShort CSignedChar CString CUnsignedChar CUnsignedInt CUnsignedLong CUnsignedLongLong CUnsignedShort CVaListPointer CVarArg CWideChar Character CharacterLiteralConvertible Collection CollectionOfOne Comparable ContiguousArray ContiguousArrayBuffer DebugPrintable Dictionary DictionaryGenerator DictionaryIndex DictionaryLiteralConvertible Double EmptyCollection EmptyGenerator EnumerateGenerator Equatable ExtendedGraphemeClusterLiteralConvertible ExtendedGraphemeClusterType ExtensibleCollection FilterCollectionView FilterCollectionViewIndex FilterGenerator FilterSequenceView Float Float32 Float64 Float80 FloatLiteralConvertible FloatLiteralType FloatingPointClassification FloatingPointNumber ForwardIndex Generator GeneratorOf GeneratorOfOne GeneratorSequence Hashable HeapBuffer HeapBufferStorage HeapBufferStorageBase ImplicitlyUnwrappedOptional IndexingGenerator Int Int16 Int32 Int64 Int8 IntEncoder IntMax Integer IntegerArithmetic IntegerLiteralConvertible IntegerLiteralType Less LifetimeManager LogicValue MapCollectionView MapSequenceGenerator MapSequenceView MaxBuiltinFloatType MaxBuiltinIntegerType Mirror MirrorDisposition MutableCollection MutableSliceable ObjectIdentifier OnHeap Optional OutputStream PermutationGenerator Printable QuickLookObject RandomAccessIndex Range RangeGenerator RawByte RawOptionSet RawRepresentable Reflectable Repeat ReverseIndex ReverseRange ReverseRangeGenerator ReverseView Sequence SequenceOf SignedInteger SignedNumber Sink SinkOf Slice SliceBuffer Sliceable StaticString Streamable StridedRangeGenerator String StringElement StringInterpolationConvertible StringLiteralConvertible StringLiteralType UInt UInt16 UInt32 UInt64 UInt8 UIntMax UTF16 UTF32 UTF8 UWord UnicodeCodec UnicodeScalar Unmanaged UnsafeArray UnsafePointer UnsignedInteger Void Word Zip2 ZipGenerator2 abs advance alignof alignofValue assert bridgeFromObjectiveC bridgeFromObjectiveCUnconditional bridgeToObjectiveC bridgeToObjectiveCUnconditional c contains count countElements countLeadingZeros debugPrint debugPrintln distance dropFirst dropLast dump encodeBitsAsWords enumerate equal false filter find getBridgedObjectiveCType getVaList indices insertionSort isBridgedToObjectiveC isBridgedVerbatimToObjectiveC isUniquelyReferenced join lexicographicalCompare map max maxElement min minElement nil numericCast partition posix print println quickSort reduce reflect reinterpretCast reverse roundUpToAlignment sizeof sizeofValue sort split startsWith strideof strideofValue swap swift toString transcode true underestimateCount unsafeReflect withExtendedLifetime withObjectAtPlusZero withUnsafePointer withUnsafePointerToObject withUnsafePointers withVaList</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">as break case class continue default deinit do dynamicType else enum </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">extension fallthrough for func if import in init is let new protocol </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">return self Self static struct subscript super switch Type typealias </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">var where while __COLUMN__ __FILE__ __FUNCTION__ __LINE__ associativity </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">didSet get infix inout left mutating none nonmutating operator override </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">postfix precedence prefix right set unowned unowned(safe) unowned(unsafe) weak willSet</span><span class="delimiter">'</span></span>;

          <span class="keyword">var</span> attributes = <span class="string"><span class="delimiter">'</span><span class="content">assignment class_protocol exported final lazy noreturn NSCopying NSManaged objc optional required auto_closure noreturn IBAction IBDesignable IBInspectable IBOutlet infix prefix postfix</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [
          <span class="comment">// html entities</span>
          {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">\&amp;</span><span class="content">[a-z]+;</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">plain</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">/</span><span class="char">\\</span><span class="content">*[</span><span class="char">\\</span><span class="content">s</span><span class="char">\\</span><span class="content">S]*</span><span class="char">\\</span><span class="content">*</span><span class="char">\\</span><span class="content">/</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>,
            <span class="key">func</span>: multiLineCCommentsAdd
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>,
            <span class="key">func</span>: stringAdd
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">b([</span><span class="char">\\</span><span class="content">d_]+(</span><span class="char">\\</span><span class="content">.[</span><span class="char">\\</span><span class="content">de_]+)?|0x[a-f0-9_]+(</span><span class="char">\\</span><span class="content">.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(getKeywordsPrependedBy(attributes, <span class="string"><span class="delimiter">'</span><span class="content">@</span><span class="delimiter">'</span></span>), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(swiftTypes), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color2</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">b([a-zA-Z_][a-zA-Z0-9_]*)</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gi</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">variable</span><span class="delimiter">'</span></span>
          }];
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">swift</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 48 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="comment">// Contributed by Chad Granum</span>
          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">^1..</span><span class="char">\\</span><span class="content">d+</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">plain bold italic</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">^ok( </span><span class="char">\\</span><span class="content">d+)?</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">^not ok( </span><span class="char">\\</span><span class="content">d+)?</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color3 bold</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">(?!^</span><span class="char">\\</span><span class="content">s*)#.*$</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">variable bold</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">^#.*$</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments bold</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="string"><span class="delimiter">'</span><span class="content">^(?!(not )?ok)[^1].*$</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }];
        }

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">tap</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Tap</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">TAP</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 49 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">break case catch class continue </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">default delete do else enum export extends false  </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">for function if implements import in instanceof </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">interface let new null package private protected </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">static return super switch </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">this throw true try typeof var while with yield</span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content"> any bool declare get module number public set string</span><span class="delimiter">'</span></span>; <span class="comment">// TypeScript-specific, everything above is common with JavaScript</span>

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: regexLib.multiLineDoubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.multiLineSingleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.singleLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.multiLineCComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }];

          <span class="local-variable">this</span>.forHtmlScript(regexLib.scriptScriptTags);
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">ts</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">typescript</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 50 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="keyword">var</span> keywords = <span class="string"><span class="delimiter">'</span><span class="content">AddHandler AddressOf AndAlso Alias And Ansi As Assembly Auto </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Boolean ByRef Byte ByVal Call Case Catch CBool CByte CChar CDate </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">CDec CDbl Char CInt Class CLng CObj Const CShort CSng CStr CType </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Date Decimal Declare Default Delegate Dim DirectCast Do Double Each </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Else ElseIf End Enum Erase Error Event Exit False Finally For Friend </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Function Get GetType GoSub GoTo Handles If Implements Imports In </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Inherits Integer Interface Is Let Lib Like Long Loop Me Mod Module </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">MustInherit MustOverride MyBase MyClass Namespace New Next Not Nothing </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">NotInheritable NotOverridable Object On Option Optional Or OrElse </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Overloads Overridable Overrides ParamArray Preserve Private Property </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Protected Public RaiseEvent ReadOnly ReDim REM RemoveHandler Resume </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Return Select Set Shadows Shared Short Single Static Step Stop String </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Structure Sub SyncLock Then Throw To True Try TypeOf Unicode Until </span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">Variant When While With WithEvents WriteOnly Xor</span><span class="delimiter">'</span></span>;

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">'.*$</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.doubleQuotedString,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="char">\s</span><span class="content">*#.*$</span><span class="delimiter">/</span><span class="modifier">gm</span></span>,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">preprocessor</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: <span class="keyword">new</span> RegExp(<span class="local-variable">this</span>.getKeywords(keywords), <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>
          }];

          <span class="local-variable">this</span>.forHtmlScript(regexLib.aspScriptTags);
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">vb</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">vbnet</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 51 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> BrushBase = __webpack_require__(<span class="integer">22</span>);
        <span class="keyword">var</span> regexLib = __webpack_require__(<span class="integer">3</span>).commonRegExp;
        <span class="keyword">var</span> XRegExp = __webpack_require__(<span class="integer">3</span>).XRegExp;
        <span class="keyword">var</span> Match = __webpack_require__(<span class="integer">5</span>).Match;

        <span class="keyword">function</span> <span class="function">Brush</span>() {
          <span class="keyword">function</span> <span class="function">process</span>(match, regexInfo) {
            <span class="keyword">var</span> code = match[<span class="integer">0</span>],
                tag = XRegExp.exec(code, XRegExp(<span class="string"><span class="delimiter">'</span><span class="content">(&amp;lt;|&lt;)[</span><span class="char">\\</span><span class="content">s</span><span class="char">\\</span><span class="content">/</span><span class="char">\\</span><span class="content">?!]*(?&lt;name&gt;[:</span><span class="char">\\</span><span class="content">w-</span><span class="char">\\</span><span class="content">.]+)</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">xg</span><span class="delimiter">'</span></span>)),
                result = [];

            <span class="keyword">if</span> (match.attributes != <span class="predefined-constant">null</span>) {
              <span class="keyword">var</span> attributes,
                  pos = <span class="integer">0</span>,
                  regex = XRegExp(<span class="string"><span class="delimiter">'</span><span class="content">(?&lt;name&gt; [</span><span class="char">\\</span><span class="content">w:.-]+)</span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="content">s*=</span><span class="char">\\</span><span class="content">s*</span><span class="delimiter">'</span></span> + <span class="string"><span class="delimiter">'</span><span class="content">(?&lt;value&gt; &quot;.*?&quot;|</span><span class="char">\'</span><span class="content">.*?</span><span class="char">\'</span><span class="content">|</span><span class="char">\\</span><span class="content">w+)</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">xg</span><span class="delimiter">'</span></span>);

              <span class="keyword">while</span> ((attributes = XRegExp.exec(code, regex, pos)) != <span class="predefined-constant">null</span>) {
                result.push(<span class="keyword">new</span> Match(attributes.name, match.index + attributes.index, <span class="string"><span class="delimiter">'</span><span class="content">color1</span><span class="delimiter">'</span></span>));
                result.push(<span class="keyword">new</span> Match(attributes.value, match.index + attributes.index + attributes[<span class="integer">0</span>].indexOf(attributes.value), <span class="string"><span class="delimiter">'</span><span class="content">string</span><span class="delimiter">'</span></span>));
                pos = attributes.index + attributes[<span class="integer">0</span>].length;
              }
            }

            <span class="keyword">if</span> (tag != <span class="predefined-constant">null</span>) result.push(<span class="keyword">new</span> Match(tag.name, match.index + tag[<span class="integer">0</span>].indexOf(tag.name), <span class="string"><span class="delimiter">'</span><span class="content">keyword</span><span class="delimiter">'</span></span>));

            <span class="keyword">return</span> result;
          }

          <span class="local-variable">this</span>.regexList = [{
            <span class="key">regex</span>: XRegExp(<span class="string"><span class="delimiter">'</span><span class="content">(</span><span class="char">\\</span><span class="content">&amp;lt;|&lt;)</span><span class="char">\\</span><span class="content">!</span><span class="char">\\</span><span class="content">[[</span><span class="char">\\</span><span class="content">w</span><span class="char">\\</span><span class="content">s]*?</span><span class="char">\\</span><span class="content">[(.|</span><span class="char">\\</span><span class="content">s)*?</span><span class="char">\\</span><span class="content">]</span><span class="char">\\</span><span class="content">](</span><span class="char">\\</span><span class="content">&amp;gt;|&gt;)</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">gm</span><span class="delimiter">'</span></span>),
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">color2</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: regexLib.xmlComments,
            <span class="key">css</span>: <span class="string"><span class="delimiter">'</span><span class="content">comments</span><span class="delimiter">'</span></span>
          }, {
            <span class="key">regex</span>: XRegExp(<span class="string"><span class="delimiter">'</span><span class="content">(&amp;lt;|&lt;)[</span><span class="char">\\</span><span class="content">s</span><span class="char">\\</span><span class="content">/</span><span class="char">\\</span><span class="content">?!]*(</span><span class="char">\\</span><span class="content">w+)(?&lt;attributes&gt;.*?)[</span><span class="char">\\</span><span class="content">s</span><span class="char">\\</span><span class="content">/</span><span class="char">\\</span><span class="content">?]*(&amp;gt;|&gt;)</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">sg</span><span class="delimiter">'</span></span>),
            <span class="key">func</span>: process
          }];
        };

        Brush.prototype = <span class="keyword">new</span> BrushBase();
        Brush.aliases = [<span class="string"><span class="delimiter">'</span><span class="content">xml</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">xhtml</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">xslt</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">html</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">plist</span><span class="delimiter">'</span></span>];
        module.exports = Brush;

<span class="comment">/***/</span> },
<span class="comment">/* 52 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports, __webpack_require__) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        <span class="keyword">var</span> _typeof = <span class="keyword">typeof</span> Symbol === <span class="string"><span class="delimiter">&quot;</span><span class="content">function</span><span class="delimiter">&quot;</span></span> &amp;&amp; <span class="keyword">typeof</span> Symbol.iterator === <span class="string"><span class="delimiter">&quot;</span><span class="content">symbol</span><span class="delimiter">&quot;</span></span> ? <span class="keyword">function</span> (obj) { <span class="keyword">return</span> <span class="keyword">typeof</span> obj; } : <span class="keyword">function</span> (obj) { <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> Symbol === <span class="string"><span class="delimiter">&quot;</span><span class="content">function</span><span class="delimiter">&quot;</span></span> &amp;&amp; obj.constructor === Symbol ? <span class="string"><span class="delimiter">&quot;</span><span class="content">symbol</span><span class="delimiter">&quot;</span></span> : <span class="keyword">typeof</span> obj; };

        <span class="comment">/*!
          * domready (c) Dustin Diaz 2014 - License MIT
          */</span>
        !<span class="keyword">function</span> (name, definition) {

          <span class="keyword">if</span> (<span class="predefined-constant">true</span>) module.exports = definition();<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define == <span class="string"><span class="delimiter">'</span><span class="content">function</span><span class="delimiter">'</span></span> &amp;&amp; _typeof(define.amd) == <span class="string"><span class="delimiter">'</span><span class="content">object</span><span class="delimiter">'</span></span>) define(definition);<span class="keyword">else</span> <span class="local-variable">this</span>[name] = definition();
        }(<span class="string"><span class="delimiter">'</span><span class="content">domready</span><span class="delimiter">'</span></span>, <span class="keyword">function</span> () {

          <span class="keyword">var</span> fns = [],
              _listener,
              doc = document,
              hack = doc.documentElement.doScroll,
              domContentLoaded = <span class="string"><span class="delimiter">'</span><span class="content">DOMContentLoaded</span><span class="delimiter">'</span></span>,
              loaded = (hack ? <span class="regexp"><span class="delimiter">/</span><span class="content">^loaded|^c</span><span class="delimiter">/</span></span> : <span class="regexp"><span class="delimiter">/</span><span class="content">^loaded|^i|^c</span><span class="delimiter">/</span></span>).test(doc.readyState);

          <span class="keyword">if</span> (!loaded) doc.addEventListener(domContentLoaded, <span class="function">_listener</span> = <span class="keyword">function</span> <span class="function">listener</span>() {
            doc.removeEventListener(domContentLoaded, _listener);
            loaded = <span class="integer">1</span>;
            <span class="keyword">while</span> (_listener = fns.shift()) {
              _listener();
            }
          });

          <span class="keyword">return</span> <span class="keyword">function</span> (fn) {
            loaded ? setTimeout(fn, <span class="integer">0</span>) : fns.push(fn);
          };
        });

<span class="comment">/***/</span> },
<span class="comment">/* 53 */</span>
<span class="comment">/***/</span> <span class="keyword">function</span>(module, exports) {

        <span class="string"><span class="delimiter">'</span><span class="content">use strict</span><span class="delimiter">'</span></span>;

        Object.defineProperty(exports, <span class="string"><span class="delimiter">&quot;</span><span class="content">__esModule</span><span class="delimiter">&quot;</span></span>, {
          <span class="key">value</span>: <span class="predefined-constant">true</span>
        });
        <span class="keyword">var</span> string = exports.<span class="function">string</span> = <span class="keyword">function</span> <span class="function">string</span>(value) {
          <span class="keyword">return</span> value.replace(<span class="regexp"><span class="delimiter">/</span><span class="content">^([A-Z])</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="keyword">function</span> (_, character) {
            <span class="keyword">return</span> character.toLowerCase();
          }).replace(<span class="regexp"><span class="delimiter">/</span><span class="content">([A-Z])</span><span class="delimiter">/</span><span class="modifier">g</span></span>, <span class="keyword">function</span> (_, character) {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">'</span><span class="content">-</span><span class="delimiter">'</span></span> + character.toLowerCase();
          });
        };

        <span class="keyword">var</span> object = exports.<span class="function">object</span> = <span class="keyword">function</span> <span class="function">object</span>(value) {
          <span class="keyword">var</span> result = {};
          Object.keys(value).forEach(<span class="keyword">function</span> (key) {
            <span class="keyword">return</span> result[string(key)] = value[key];
          });
          <span class="keyword">return</span> result;
        };

<span class="comment">/***/</span> }
<span class="comment">/******/</span> ]);
<span class="comment">//# sourceMappingURL=syntaxhighlighter.js.map</span></code></pre>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-08-03 15:39:20 PDT
</div>
</div>
</body>
</html>